package typingsSlinky.workboxWebpackPlugin.mod

import org.scalablytyped.runtime.StringDictionary
import typingsSlinky.workboxWebpackPlugin.AnonIntegrity
import typingsSlinky.workboxWebpackPlugin.AnonManifest
import typingsSlinky.workboxWebpackPlugin.workboxWebpackPluginStrings.production
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait CommonOptions extends js.Object {
  /**
  	 * A list of entries to be precached, in addition to any entries that are generated as part of the build configuration.
  	 */
  var additionalManifestEntries: js.UndefOr[js.Array[AnonIntegrity | String]] = js.native
  /**
  	 * By default, Workbox will precache assets regardless of which chunk the asset is part of.
  	 *
  	 * If you would like to override this behavior via a whitelist, specify one or more chunk names. Only assets belonging to those chunks will be precached;
  	 * any assets belonging to another chunk or without a chunk association will be skipped.
  	 *
  	 * @default []
  	 * @example chunks: ['chunk-name-1', 'chunk-name-2']
  	 */
  var chunks: js.UndefOr[js.Array[String]] = js.native
  /**
  	 * Assets that match this regex will be assumed to be uniquely versioned via their URL, and exempted from the normal HTTP cache-busting that's done when populating the precache.
  	 *
  	 * While not required, it's recommended that if your existing build process already inserts a `[hash]` value into each filename, you provide a RegExp that will detect those values,
  	 * as it will reduce the amount of bandwidth consumed when precaching.
  	 *
  	 * @default null
  	 * @example dontCacheBustUrlsMatching: /\.\w{8}\./
  	 */
  var dontCacheBustUrlsMatching: js.UndefOr[js.RegExp | Null] = js.native
  /**
  	 * This allows you to specifically omit assets matching any of the provided criteria from being included in the precache manifest. It provides a filename-based approach to filtering.
  	 *
  	 * This filtering takes place after any chunk-based filtering is applied.
  	 *
  	 * @default [/\.map$/, /^manifest.*\.js(?:on)?$/]
  	 * @example exclude: [/\.jpg$/, /\.png$/]
  	 */
  var exclude: js.UndefOr[js.Array[String | js.RegExp]] = js.native
  /**
  	 * By default, Workbox will precache all assets generated by the webpack compilation, regardless of which chunk the asset is part of.
  	 *
  	 * If you would like to override this behavior via a blacklist, specify one or more chunk names. Any assets belonging to those chunks will be skipped.
  	 *
  	 * @default []
  	 * @example excludeChunks: ['chunk-name-1', 'chunk-name-2']
  	 */
  var excludeChunks: js.UndefOr[js.Array[String]] = js.native
  /**
  	 * The base directory you wish to match `globPatterns` against, relative to the current working directory.
  	 *
  	 * If you do set this, make sure to also configure `globPatterns`.
  	 *
  	 * @default undefined
  	 * @example globDirectory: '.'
  	 */
  var globDirectory: js.UndefOr[String] = js.native
  /**
  	 * Determines whether or not symlinks are followed when generating the precache manifest.
  	 *
  	 * For more information, see the definition of `follow` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default true
  	 * @example globFollow: false
  	 */
  var globFollow: js.UndefOr[Boolean] = js.native
  /**
  	 * A set of patterns matching files to always exclude when generating the precache manifest.
  	 *
  	 * For more information, see the definition of `ignore` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default ['node_modules/ **\/ *']
  	 * @example globIgnores: ['**\/ignored.html']
  	 */
  var globIgnores: js.UndefOr[js.Array[String]] = js.native
  /**
  	 * Files matching against any of these patterns will be included in the precache manifest.
  	 *
  	 * For more information, see the [glob primer](https://github.com/isaacs/node-glob#glob-primer).
  	 *
  	 * Note: Setting `globPatterns` is often unnecessary when using the `workbox-webpack-plugin`, which will automatically precache files that are part of the webpack build pipeline by default.
  	 * When using the webpack plugin, only set it when you need to cache
  	 * [non-webpack assets](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin#cache_additional_non-webpack_assets).
  	 *
  	 * @default []
  	 * @example globPatterns: ['dist/ *.{js,png,html,css}']
  	 */
  var globPatterns: js.UndefOr[js.Array[String]] = js.native
  /**
  	 * If `true`, an error reading a directory when generating a precache manifest will cause the build to fail. If `false`, the problematic directory will be skipped.
  	 *
  	 * For more information, see the definition of `strict` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default true
  	 * @example globStrict: false
  	 */
  var globStrict: js.UndefOr[Boolean] = js.native
  /**
  	 * One or more names of webpack chunks.
  	 * The content of those chunks will be included in the generated service worker, via a call to importScripts()
  	 */
  var importScriptsViaChunks: js.UndefOr[js.Array[String]] = js.native
  /**
  	 * Workbox creates assets as part of your webpack build process: a precache manifest file, and potentially a local copy of the Workbox libraries (if `importWorkboxFrom` is set to `'local'`).
  	 *
  	 * These assets will, by default, be created at the root of your webpack build directory, i.e. `output.path`. You can set the `importsDirectory` option if you want these assets to be created in
  	 * a subdirectory of `output.path` instead of at the top-level.
  	 *
  	 * Note: This option does not effect where the main service worker JavaScript file is created. That is determined by the `swDest` option.
  	 *
  	 * @default ''
  	 * @example importsDirectory: 'wb-assets'
  	 */
  var importsDirectory: js.UndefOr[String] = js.native
  /**
  	 * This allows you to only include assets matching any of the provided criteria when creating the precache manifest. It provides a filename-based approach to filtering.
  	 *
  	 * This filtering takes place after any chunk-based filtering is applied.
  	 *
  	 * In keeping with [webpack convention](https://webpack.js.org/configuration/module/#condition), the option `test` can be used as an alias/alternative to `include`.
  	 *
  	 * @default []
  	 * @example include: [/\.html$/, /\.js$/]
  	 * @alias test
  	 */
  var include: js.UndefOr[js.Array[String | js.RegExp]] = js.native
  /**
  	 * One or more [`ManifestTransform`](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-build#.ManifestTransform)
  	 * functions, which will be applied sequentially against the generated manifest.
  	 *
  	 * If `modifyUrlPrefix` or `dontCacheBustUrlsMatching` are also specified, their corresponding transformations will be applied first.
  	 */
  var manifestTransforms: js.UndefOr[
    (js.Array[js.Function1[/* originalManifest */ js.Array[ManifestEntry], AnonManifest]]) | Null
  ] = js.native
  /**
  	 * This value can be used to determine the maximum size of files that will be precached. This prevents you from inadvertantly precaching very large files that might have
  	 * accidentally matched one of your patterns.
  	 *
  	 * @default 2097152
  	 * @example maximumFileSizeToCacheInBytes: 4 * 1024 * 1024
  	 */
  var maximumFileSizeToCacheInBytes: js.UndefOr[Double] = js.native
  /**
  	 * If set to 'production', then an optimized service worker bundle that excludes debugging info will be produced.
  	 * If not explicitly configured here, the mode value configured in the current webpack compilation will be used
  	 */
  var mode: js.UndefOr[production | String] = js.native
  /**
  	 * A mapping of prefixes that, if present in an entry in the precache manifest, will be replaced with the corresponding value.
  	 *
  	 * This can be used to, for example, remove or add a path prefix from a manifest entry if your web hosting setup doesn't match your local filesystem setup.
  	 *
  	 * As an alternative with more flexibility, you can use the `manifestTransforms` option and provide a function that modifies the entries in the manifest using whatever logic you provide.
  	 *
  	 * @default null
  	 * @example modifyUrlPrefix: { '/dist': '' }
  	 */
  var modifyUrlPrefix: js.UndefOr[StringDictionary[String] | Null] = js.native
  /**
  	 * Workbox automatically creates a JavaScript file that contains information about URLs that need to be precached. By default, this file is called `precache-manifest.[manifestHash].js`,
  	 * where `[manifestHash]` is automatically replaced by a unique value that identifies the contents of the file.
  	 *
  	 * `precacheManifestFilename` can be used to override this default filename. You must include the string `[manifestHash]` somewhere as part of the filename.
  	 *
  	 * If you'd like to change the output directory to which the precache manifest is written, you can configure the `importsDirectory` option.
  	 *
  	 * @default 'precache-manifest.[manifestHash].js'
  	 * @example precacheManifestFilename: 'wb-manifest.[manifestHash].js'
  	 */
  var precacheManifestFilename: js.UndefOr[String] = js.native
  /**
  	 * The path and filename of the service worker file that will be created by the build process, relative to the webpack output directory.
  	 *
  	 * @default 'service-worker.js'
  	 * @example swDest: 'custom-sw-name.js'
  	 */
  var swDest: js.UndefOr[String] = js.native
  /**
  	 * If a URL is rendered generated based on some server-side logic, its contents may depend on multiple files or on some other unique string value.
  	 *
  	 * If used with an array of strings, they will be interpreted as glob patterns, and the contents of any files matching the patterns will be used to uniquely version the URL.
  	 *
  	 * If used with a single string, it will be interpreted as unique versioning information that you've generated out of band for a given URL.
  	 *
  	 * @default null
  	 */
  var templatedUrls: js.UndefOr[(StringDictionary[String | js.Array[String]]) | Null] = js.native
  var test: js.UndefOr[js.Array[String | js.RegExp]] = js.native
}

object CommonOptions {
  @scala.inline
  def apply(): CommonOptions = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[CommonOptions]
  }
  @scala.inline
  implicit class CommonOptionsOps[Self <: CommonOptions] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withAdditionalManifestEntries(value: js.Array[AnonIntegrity | String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("additionalManifestEntries")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAdditionalManifestEntries: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("additionalManifestEntries")(js.undefined)
        ret
    }
    @scala.inline
    def withChunks(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("chunks")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutChunks: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("chunks")(js.undefined)
        ret
    }
    @scala.inline
    def withDontCacheBustUrlsMatching(value: js.RegExp): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dontCacheBustUrlsMatching")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDontCacheBustUrlsMatching: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dontCacheBustUrlsMatching")(js.undefined)
        ret
    }
    @scala.inline
    def withDontCacheBustUrlsMatchingNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dontCacheBustUrlsMatching")(null)
        ret
    }
    @scala.inline
    def withExclude(value: js.Array[String | js.RegExp]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("exclude")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutExclude: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("exclude")(js.undefined)
        ret
    }
    @scala.inline
    def withExcludeChunks(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("excludeChunks")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutExcludeChunks: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("excludeChunks")(js.undefined)
        ret
    }
    @scala.inline
    def withGlobDirectory(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globDirectory")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGlobDirectory: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globDirectory")(js.undefined)
        ret
    }
    @scala.inline
    def withGlobFollow(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globFollow")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGlobFollow: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globFollow")(js.undefined)
        ret
    }
    @scala.inline
    def withGlobIgnores(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globIgnores")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGlobIgnores: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globIgnores")(js.undefined)
        ret
    }
    @scala.inline
    def withGlobPatterns(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globPatterns")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGlobPatterns: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globPatterns")(js.undefined)
        ret
    }
    @scala.inline
    def withGlobStrict(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globStrict")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGlobStrict: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globStrict")(js.undefined)
        ret
    }
    @scala.inline
    def withImportScriptsViaChunks(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("importScriptsViaChunks")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutImportScriptsViaChunks: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("importScriptsViaChunks")(js.undefined)
        ret
    }
    @scala.inline
    def withImportsDirectory(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("importsDirectory")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutImportsDirectory: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("importsDirectory")(js.undefined)
        ret
    }
    @scala.inline
    def withInclude(value: js.Array[String | js.RegExp]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("include")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutInclude: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("include")(js.undefined)
        ret
    }
    @scala.inline
    def withManifestTransforms(value: js.Array[js.Function1[/* originalManifest */ js.Array[ManifestEntry], AnonManifest]]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("manifestTransforms")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutManifestTransforms: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("manifestTransforms")(js.undefined)
        ret
    }
    @scala.inline
    def withManifestTransformsNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("manifestTransforms")(null)
        ret
    }
    @scala.inline
    def withMaximumFileSizeToCacheInBytes(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("maximumFileSizeToCacheInBytes")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutMaximumFileSizeToCacheInBytes: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("maximumFileSizeToCacheInBytes")(js.undefined)
        ret
    }
    @scala.inline
    def withMode(value: production | String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("mode")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutMode: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("mode")(js.undefined)
        ret
    }
    @scala.inline
    def withModifyUrlPrefix(value: StringDictionary[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("modifyUrlPrefix")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutModifyUrlPrefix: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("modifyUrlPrefix")(js.undefined)
        ret
    }
    @scala.inline
    def withModifyUrlPrefixNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("modifyUrlPrefix")(null)
        ret
    }
    @scala.inline
    def withPrecacheManifestFilename(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("precacheManifestFilename")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPrecacheManifestFilename: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("precacheManifestFilename")(js.undefined)
        ret
    }
    @scala.inline
    def withSwDest(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("swDest")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSwDest: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("swDest")(js.undefined)
        ret
    }
    @scala.inline
    def withTemplatedUrls(value: StringDictionary[String | js.Array[String]]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("templatedUrls")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTemplatedUrls: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("templatedUrls")(js.undefined)
        ret
    }
    @scala.inline
    def withTemplatedUrlsNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("templatedUrls")(null)
        ret
    }
    @scala.inline
    def withTest(value: js.Array[String | js.RegExp]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("test")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTest: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("test")(js.undefined)
        ret
    }
  }
  
}

