package typingsSlinky.stripe.mod.subscriptions

import typingsSlinky.stripe.AnonAmountgte
import typingsSlinky.stripe.mod.IList
import typingsSlinky.stripe.mod.IMetadata
import typingsSlinky.stripe.mod.IResourceObject
import typingsSlinky.stripe.mod.coupons.IDiscount
import typingsSlinky.stripe.mod.customers.ICustomer
import typingsSlinky.stripe.mod.invoices.IInvoice
import typingsSlinky.stripe.mod.paymentMethods.IPaymentMethod
import typingsSlinky.stripe.mod.plans.IPlan
import typingsSlinky.stripe.mod.subscriptionItems.ISubscriptionItem
import typingsSlinky.stripe.mod.taxRates.ITaxRate
import typingsSlinky.stripe.stripeStrings.subscription
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to
  * a particular plan you've created: https://stripe.com/docs/api#create_plan
  */
@js.native
trait ISubscription extends IResourceObject {
  /**
    * A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to
    * the application owner's Stripe account each billing period.
    */
  var application_fee_percent: Double | Null = js.native
  /**
    * Either `charge_automatically`, or `send_invoice`.
    * This field has been renamed to collection_method and will be removed in a future API version.
    */
  var billing: SubscriptionBilling = js.native
  /**
    * Determines the date of the first full invoice, and, for plans with month or year intervals, the day of the month
    * for subsequent invoices.
    */
  var billing_cycle_anchor: Double = js.native
  /**
    * Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.
    */
  var billing_thresholds: Null | AnonAmountgte = js.native
  /**
    * A date in the future at which the subscription will automatically get canceled.
    */
  var cancel_at: Double | Null = js.native
  /**
    * If the subscription has been canceled with the at_period_end flag set to true, cancel_at_period_end on the
    * subscription will be true. You can use this attribute to determine whether a subscription that has a status
    * of active is scheduled to be canceled at the end of the current period.
    */
  var cancel_at_period_end: Boolean = js.native
  /**
    * If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with
    * cancel_at_period_end, canceled_at will still reflect the date of the initial cancellation request, not the end of the
    * subscription period when the subscription is automatically moved to a canceled state.
    */
  var canceled_at: Double | Null = js.native
  /**
    * Either "charge_automatically", or "send_invoice". When charging automatically, Stripe will attempt to pay this subscription at the
    * end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an
    * invoice with payment instructions.
    */
  var collection_method: SubscriptionBilling = js.native
  /**
    * Time at which the object was created. Measured in seconds since the Unix epoch.
    */
  var created: Double = js.native
  /**
    * End of the current period that the subscription has been invoiced for. At the end of this period, a new invoice will be created.
    */
  var current_period_end: Double = js.native
  /**
    * Start of the current period that the subscription has been invoiced for
    */
  var current_period_start: Double = js.native
  /**
    * ID of the customer who owns the subscription. [Expandable]
    */
  var customer: String | ICustomer = js.native
  /**
    * Number of days a customer has to pay invoices generated by this subscription. This value will be null for
    * subscriptions where billing=charge_automatically.
    */
  var days_until_due: Double | Null = js.native
  /**
    * ID of the default payment method for the subscription. It must belong to the customer associated with the subscription.
    * If not set, invoices will use the default payment method in the customer’s invoice settings. [Expandable]
    */
  var default_payment_method: String | IPaymentMethod | Null = js.native
  /**
    * ID of the default payment source for the subscription.
    * It must belong to the customer associated with the subscription and be in a chargeable state.
    * If not set, defaults to the customer’s default source. [Expandable]
    */
  var default_source: String | Null = js.native
  /**
    * The tax rates that will apply to any subscription item that does not have tax_rates set.
    * Invoices created will have their default_tax_rates populated from the subscription.
    */
  var default_tax_rates: js.Array[ITaxRate] = js.native
  /**
    * Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a
    * subscription overrides a discount applied on a customer-wide basis.
    */
  var discount: IDiscount | Null = js.native
  /**
    * If the subscription has ended (either because it was canceled or because the customer was switched to a subscription
    * to a new plan), the date the subscription ended
    */
  var ended_at: Double | Null = js.native
  /**
    * List of subscription items, each with an attached plan.
    */
  var items: IList[ISubscriptionItem] = js.native
  /**
    * The most recent invoice this subscription has generated. [Expandable]
    */
  var latest_invoice: IInvoice | String | Null = js.native
  /**
    * Has the value true if the object exists in live mode or the value false if the object exists in test mode.
    */
  var livemode: Boolean = js.native
  /**
    * Set of key-value pairs that you can attach to an object. This can be useful for storing additional information
    * about the object in a structured format.
    */
  var metadata: IMetadata = js.native
  /**
    * Value is "subscription"
    */
  @JSName("object")
  var object_ISubscription: subscription = js.native
  /**
    * Hash describing the plan the customer is subscribed to.  Only set if the subscription
    * contains a single plan.
    */
  var plan: js.UndefOr[IPlan | Null] = js.native
  /**
    * The quantity of the plan to which the customer is subscribed. For example, if your plan is $10/user/month,
    * and your customer has 5 users, you could pass 5 as the quantity to have the customer charged $50 (5 x $10) monthly.
    * Only set if the subscription contains a single plan.
    */
  var quantity: js.UndefOr[Double] = js.native
  /**
    * Date of the last substantial change to this subscription. For example, a change to the items array,
    * or a change of status, will reset this timestamp.
    */
  var start: Double = js.native
  /**
    * Date when the subscription was first created. The date might differ from the created date due to backdating.
    */
  var start_date: Double = js.native
  /**
    * Possible values are `incomplete`, `incomplete_expired`, `trialing`, `active`,
    * `past_due`, `canceled`, or `unpaid`.
    *
    * For `billing=charge_automatically` a subscription moves into `incomplete` if the
    * initial payment attempt fails. A subscription in this state can only have metadata
    * and default_source updated. Once the first invoice is paid, the subscription moves
    * into an `active` state. If the first invoice is not paid within 23 hours, the
    * subscription transitions to `incomplete_expired`. This is a terminal state, the open
    * invoice will be voided and no further invoices will be generated.
    *
    * A subscription that is currently in a trial period is `trialing` and moves to
    * `active` when the trial period is over.
    *
    * If subscription `billing=charge_automatically` it becomes `past_due` when payment to
    * renew it fails and `canceled` or `unpaid` (depending on your subscriptions settings)
    * when Stripe has exhausted all payment retry attempts.
    *
    * If subscription `billing=send_invoice` it becomes `past_due` when its invoice is not
    * paid by the due date, and `canceled` or `unpaid` if it is still not paid by an
    * additional deadline after that. Note that when a subscription has a status of
    * `unpaid`, no subsequent invoices will be attempted (invoices will be created, but
    * then immediately automatically closed). After receiving updated payment information
    * from a customer, you may choose to reopen and pay their closed invoices.
    */
  var status: SubscriptionStatus = js.native
  /**
    * If provided, each invoice created by this subscription will apply the tax rate, increasing the amount billed to the customer.
    */
  var tax_percent: Double | Null = js.native
  /**
    * If the subscription has a trial, the end of that trial.
    */
  var trial_end: Double | Null = js.native
  /**
    * If the subscription has a trial, the beginning of that trial.
    */
  var trial_start: Double | Null = js.native
}

object ISubscription {
  @scala.inline
  def apply(
    billing: SubscriptionBilling,
    billing_cycle_anchor: Double,
    cancel_at_period_end: Boolean,
    collection_method: SubscriptionBilling,
    created: Double,
    current_period_end: Double,
    current_period_start: Double,
    customer: String | ICustomer,
    default_tax_rates: js.Array[ITaxRate],
    id: String,
    items: IList[ISubscriptionItem],
    livemode: Boolean,
    metadata: IMetadata,
    `object`: subscription,
    start: Double,
    start_date: Double,
    status: SubscriptionStatus
  ): ISubscription = {
    val __obj = js.Dynamic.literal(billing = billing.asInstanceOf[js.Any], billing_cycle_anchor = billing_cycle_anchor.asInstanceOf[js.Any], cancel_at_period_end = cancel_at_period_end.asInstanceOf[js.Any], collection_method = collection_method.asInstanceOf[js.Any], created = created.asInstanceOf[js.Any], current_period_end = current_period_end.asInstanceOf[js.Any], current_period_start = current_period_start.asInstanceOf[js.Any], customer = customer.asInstanceOf[js.Any], default_tax_rates = default_tax_rates.asInstanceOf[js.Any], id = id.asInstanceOf[js.Any], items = items.asInstanceOf[js.Any], livemode = livemode.asInstanceOf[js.Any], metadata = metadata.asInstanceOf[js.Any], start = start.asInstanceOf[js.Any], start_date = start_date.asInstanceOf[js.Any], status = status.asInstanceOf[js.Any])
    __obj.updateDynamic("object")(`object`.asInstanceOf[js.Any])
    __obj.asInstanceOf[ISubscription]
  }
  @scala.inline
  implicit class ISubscriptionOps[Self <: ISubscription] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withBilling(value: SubscriptionBilling): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("billing")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withBilling_cycle_anchor(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("billing_cycle_anchor")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCancel_at_period_end(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cancel_at_period_end")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCollection_method(value: SubscriptionBilling): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("collection_method")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCreated(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("created")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCurrent_period_end(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("current_period_end")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCurrent_period_start(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("current_period_start")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCustomer(value: String | ICustomer): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("customer")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDefault_tax_rates(value: js.Array[ITaxRate]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_tax_rates")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withItems(value: IList[ISubscriptionItem]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("items")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLivemode(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("livemode")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withMetadata(value: IMetadata): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("metadata")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withObject(value: subscription): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("object")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withStart(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("start")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withStart_date(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("start_date")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withStatus(value: SubscriptionStatus): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("status")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withApplication_fee_percent(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("application_fee_percent")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withApplication_fee_percentNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("application_fee_percent")(null)
        ret
    }
    @scala.inline
    def withBilling_thresholds(value: AnonAmountgte): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("billing_thresholds")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withBilling_thresholdsNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("billing_thresholds")(null)
        ret
    }
    @scala.inline
    def withCancel_at(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cancel_at")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCancel_atNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cancel_at")(null)
        ret
    }
    @scala.inline
    def withCanceled_at(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("canceled_at")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCanceled_atNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("canceled_at")(null)
        ret
    }
    @scala.inline
    def withDays_until_due(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("days_until_due")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDays_until_dueNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("days_until_due")(null)
        ret
    }
    @scala.inline
    def withDefault_payment_method(value: String | IPaymentMethod): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_payment_method")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDefault_payment_methodNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_payment_method")(null)
        ret
    }
    @scala.inline
    def withDefault_source(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_source")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDefault_sourceNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("default_source")(null)
        ret
    }
    @scala.inline
    def withDiscount(value: IDiscount): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("discount")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDiscountNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("discount")(null)
        ret
    }
    @scala.inline
    def withEnded_at(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ended_at")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withEnded_atNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ended_at")(null)
        ret
    }
    @scala.inline
    def withLatest_invoice(value: IInvoice | String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("latest_invoice")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLatest_invoiceNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("latest_invoice")(null)
        ret
    }
    @scala.inline
    def withPlan(value: IPlan): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("plan")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPlan: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("plan")(js.undefined)
        ret
    }
    @scala.inline
    def withPlanNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("plan")(null)
        ret
    }
    @scala.inline
    def withQuantity(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("quantity")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutQuantity: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("quantity")(js.undefined)
        ret
    }
    @scala.inline
    def withTax_percent(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tax_percent")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withTax_percentNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tax_percent")(null)
        ret
    }
    @scala.inline
    def withTrial_end(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("trial_end")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withTrial_endNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("trial_end")(null)
        ret
    }
    @scala.inline
    def withTrial_start(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("trial_start")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withTrial_startNull: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("trial_start")(null)
        ret
    }
  }
  
}

