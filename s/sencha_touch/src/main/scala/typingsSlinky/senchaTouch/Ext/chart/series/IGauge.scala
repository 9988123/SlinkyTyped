package typingsSlinky.senchaTouch.Ext.chart.series

import typingsSlinky.senchaTouch.Ext.Array
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait IGauge extends ISeries {
  /** [Config Option] (String) */
  var angleField: js.UndefOr[String] = js.native
  /** [Config Option] (Number) */
  var donut: js.UndefOr[Double] = js.native
  /** [Config Option] (String) */
  var field: js.UndefOr[String] = js.native
  /** [Method] Returns the value of angleField
  		* @returns String
  		*/
  var getAngleField: js.UndefOr[js.Function0[String]] = js.native
  /** [Method] Returns the value of center
  		* @returns Array
  		*/
  var getCenter: js.UndefOr[js.Function0[Array]] = js.native
  /** [Method] Returns the value of donut
  		* @returns Number
  		*/
  var getDonut: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of field
  		* @returns String
  		*/
  var getField: js.UndefOr[js.Function0[String]] = js.native
  /** [Method] Returns the value of maximum
  		* @returns Number
  		*/
  var getMaximum: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of minimum
  		* @returns Number
  		*/
  var getMinimum: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of needle
  		* @returns Boolean
  		*/
  var getNeedle: js.UndefOr[js.Function0[Boolean]] = js.native
  /** [Method] Returns the value of needleLength
  		* @returns Number
  		*/
  var getNeedleLength: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of needleLengthRatio
  		* @returns Number
  		*/
  var getNeedleLengthRatio: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of needleWidth
  		* @returns Number
  		*/
  var getNeedleWidth: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of radius
  		* @returns Number
  		*/
  var getRadius: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of region
  		* @returns Array
  		*/
  var getRegion: js.UndefOr[js.Function0[Array]] = js.native
  /** [Method] Returns the value of rotation
  		* @returns Number
  		*/
  var getRotation: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of sectors
  		* @returns Array
  		*/
  var getSectors: js.UndefOr[js.Function0[Array]] = js.native
  /** [Method] Returns the value of totalAngle
  		* @returns Object
  		*/
  var getTotalAngle: js.UndefOr[js.Function0[_]] = js.native
  /** [Method] Returns the value of value
  		* @returns Number
  		*/
  var getValue: js.UndefOr[js.Function0[Double]] = js.native
  /** [Method] Returns the value of wholeDisk
  		* @returns Boolean
  		*/
  var getWholeDisk: js.UndefOr[js.Function0[Boolean]] = js.native
  /** [Config Option] (Number) */
  var maximum: js.UndefOr[Double] = js.native
  /** [Config Option] (Number) */
  var minimum: js.UndefOr[Double] = js.native
  /** [Config Option] (Boolean) */
  var needle: js.UndefOr[Boolean] = js.native
  /** [Config Option] (Number) */
  var needleLength: js.UndefOr[Double] = js.native
  /** [Config Option] (Number) */
  var needleLengthRatio: js.UndefOr[Double] = js.native
  /** [Config Option] (Number) */
  var needleWidth: js.UndefOr[Double] = js.native
  /** [Config Option] (Array) */
  var sectors: js.UndefOr[Array] = js.native
  /** [Method] Sets the value of angleField
  		* @param angleField String The new value.
  		*/
  var setAngleField: js.UndefOr[js.Function1[/* angleField */ js.UndefOr[String], Unit]] = js.native
  /** [Method] Sets the value of center
  		* @param center Array The new value.
  		*/
  var setCenter: js.UndefOr[js.Function1[/* center */ js.UndefOr[Array], Unit]] = js.native
  /** [Method] Sets the value of donut
  		* @param donut Number The new value.
  		*/
  var setDonut: js.UndefOr[js.Function1[/* donut */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of field
  		* @param field String The new value.
  		*/
  var setField: js.UndefOr[js.Function1[/* field */ js.UndefOr[String], Unit]] = js.native
  /** [Method] Sets the value of maximum
  		* @param maximum Number The new value.
  		*/
  var setMaximum: js.UndefOr[js.Function1[/* maximum */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of minimum
  		* @param minimum Number The new value.
  		*/
  var setMinimum: js.UndefOr[js.Function1[/* minimum */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of needle
  		* @param needle Boolean The new value.
  		*/
  var setNeedle: js.UndefOr[js.Function1[/* needle */ js.UndefOr[Boolean], Unit]] = js.native
  /** [Method] Sets the value of needleLength
  		* @param needleLength Number The new value.
  		*/
  var setNeedleLength: js.UndefOr[js.Function1[/* needleLength */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of needleLengthRatio
  		* @param needleLengthRatio Number The new value.
  		*/
  var setNeedleLengthRatio: js.UndefOr[js.Function1[/* needleLengthRatio */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of needleWidth
  		* @param needleWidth Number The new value.
  		*/
  var setNeedleWidth: js.UndefOr[js.Function1[/* needleWidth */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of radius
  		* @param radius Number The new value.
  		*/
  var setRadius: js.UndefOr[js.Function1[/* radius */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of region
  		* @param region Array The new value.
  		*/
  var setRegion: js.UndefOr[js.Function1[/* region */ js.UndefOr[Array], Unit]] = js.native
  /** [Method] Sets the value of rotation
  		* @param rotation Number The new value.
  		*/
  var setRotation: js.UndefOr[js.Function1[/* rotation */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of sectors
  		* @param sectors Array The new value.
  		*/
  var setSectors: js.UndefOr[js.Function1[/* sectors */ js.UndefOr[Array], Unit]] = js.native
  /** [Method] Sets the value of totalAngle
  		* @param totalAngle Object The new value.
  		*/
  var setTotalAngle: js.UndefOr[js.Function1[/* totalAngle */ js.UndefOr[js.Any], Unit]] = js.native
  /** [Method] Sets the value of value
  		* @param value Number The new value.
  		*/
  var setValue: js.UndefOr[js.Function1[/* value */ js.UndefOr[Double], Unit]] = js.native
  /** [Method] Sets the value of wholeDisk
  		* @param wholeDisk Boolean The new value.
  		*/
  var setWholeDisk: js.UndefOr[js.Function1[/* wholeDisk */ js.UndefOr[Boolean], Unit]] = js.native
  /** [Config Option] (Number) */
  var value: js.UndefOr[Double] = js.native
  /** [Config Option] (Boolean) */
  var wholeDisk: js.UndefOr[Boolean] = js.native
}

object IGauge {
  @scala.inline
  def apply(): IGauge = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[IGauge]
  }
  @scala.inline
  implicit class IGaugeOps[Self <: IGauge] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withAngleField(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("angleField")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAngleField: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("angleField")(js.undefined)
        ret
    }
    @scala.inline
    def withDonut(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("donut")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDonut: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("donut")(js.undefined)
        ret
    }
    @scala.inline
    def withField(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("field")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutField: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("field")(js.undefined)
        ret
    }
    @scala.inline
    def withGetAngleField(value: () => String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getAngleField")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetAngleField: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getAngleField")(js.undefined)
        ret
    }
    @scala.inline
    def withGetCenter(value: () => Array): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getCenter")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetCenter: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getCenter")(js.undefined)
        ret
    }
    @scala.inline
    def withGetDonut(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getDonut")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetDonut: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getDonut")(js.undefined)
        ret
    }
    @scala.inline
    def withGetField(value: () => String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getField")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetField: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getField")(js.undefined)
        ret
    }
    @scala.inline
    def withGetMaximum(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getMaximum")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetMaximum: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getMaximum")(js.undefined)
        ret
    }
    @scala.inline
    def withGetMinimum(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getMinimum")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetMinimum: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getMinimum")(js.undefined)
        ret
    }
    @scala.inline
    def withGetNeedle(value: () => Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getNeedle")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetNeedle: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getNeedle")(js.undefined)
        ret
    }
    @scala.inline
    def withGetNeedleLength(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getNeedleLength")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetNeedleLength: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getNeedleLength")(js.undefined)
        ret
    }
    @scala.inline
    def withGetNeedleLengthRatio(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getNeedleLengthRatio")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetNeedleLengthRatio: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getNeedleLengthRatio")(js.undefined)
        ret
    }
    @scala.inline
    def withGetNeedleWidth(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getNeedleWidth")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetNeedleWidth: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getNeedleWidth")(js.undefined)
        ret
    }
    @scala.inline
    def withGetRadius(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getRadius")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetRadius: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getRadius")(js.undefined)
        ret
    }
    @scala.inline
    def withGetRegion(value: () => Array): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getRegion")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetRegion: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getRegion")(js.undefined)
        ret
    }
    @scala.inline
    def withGetRotation(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getRotation")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetRotation: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getRotation")(js.undefined)
        ret
    }
    @scala.inline
    def withGetSectors(value: () => Array): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getSectors")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetSectors: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getSectors")(js.undefined)
        ret
    }
    @scala.inline
    def withGetTotalAngle(value: () => _): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getTotalAngle")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetTotalAngle: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getTotalAngle")(js.undefined)
        ret
    }
    @scala.inline
    def withGetValue(value: () => Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getValue")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetValue: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getValue")(js.undefined)
        ret
    }
    @scala.inline
    def withGetWholeDisk(value: () => Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getWholeDisk")(js.Any.fromFunction0(value))
        ret
    }
    @scala.inline
    def withoutGetWholeDisk: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("getWholeDisk")(js.undefined)
        ret
    }
    @scala.inline
    def withMaximum(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("maximum")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutMaximum: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("maximum")(js.undefined)
        ret
    }
    @scala.inline
    def withMinimum(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("minimum")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutMinimum: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("minimum")(js.undefined)
        ret
    }
    @scala.inline
    def withNeedle(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("needle")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutNeedle: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("needle")(js.undefined)
        ret
    }
    @scala.inline
    def withNeedleLength(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("needleLength")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutNeedleLength: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("needleLength")(js.undefined)
        ret
    }
    @scala.inline
    def withNeedleLengthRatio(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("needleLengthRatio")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutNeedleLengthRatio: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("needleLengthRatio")(js.undefined)
        ret
    }
    @scala.inline
    def withNeedleWidth(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("needleWidth")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutNeedleWidth: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("needleWidth")(js.undefined)
        ret
    }
    @scala.inline
    def withSectors(value: Array): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sectors")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSectors: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sectors")(js.undefined)
        ret
    }
    @scala.inline
    def withSetAngleField(value: /* angleField */ js.UndefOr[String] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setAngleField")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetAngleField: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setAngleField")(js.undefined)
        ret
    }
    @scala.inline
    def withSetCenter(value: /* center */ js.UndefOr[Array] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setCenter")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetCenter: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setCenter")(js.undefined)
        ret
    }
    @scala.inline
    def withSetDonut(value: /* donut */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setDonut")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetDonut: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setDonut")(js.undefined)
        ret
    }
    @scala.inline
    def withSetField(value: /* field */ js.UndefOr[String] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setField")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetField: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setField")(js.undefined)
        ret
    }
    @scala.inline
    def withSetMaximum(value: /* maximum */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setMaximum")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetMaximum: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setMaximum")(js.undefined)
        ret
    }
    @scala.inline
    def withSetMinimum(value: /* minimum */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setMinimum")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetMinimum: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setMinimum")(js.undefined)
        ret
    }
    @scala.inline
    def withSetNeedle(value: /* needle */ js.UndefOr[Boolean] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setNeedle")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetNeedle: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setNeedle")(js.undefined)
        ret
    }
    @scala.inline
    def withSetNeedleLength(value: /* needleLength */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setNeedleLength")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetNeedleLength: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setNeedleLength")(js.undefined)
        ret
    }
    @scala.inline
    def withSetNeedleLengthRatio(value: /* needleLengthRatio */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setNeedleLengthRatio")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetNeedleLengthRatio: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setNeedleLengthRatio")(js.undefined)
        ret
    }
    @scala.inline
    def withSetNeedleWidth(value: /* needleWidth */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setNeedleWidth")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetNeedleWidth: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setNeedleWidth")(js.undefined)
        ret
    }
    @scala.inline
    def withSetRadius(value: /* radius */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setRadius")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetRadius: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setRadius")(js.undefined)
        ret
    }
    @scala.inline
    def withSetRegion(value: /* region */ js.UndefOr[Array] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setRegion")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetRegion: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setRegion")(js.undefined)
        ret
    }
    @scala.inline
    def withSetRotation(value: /* rotation */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setRotation")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetRotation: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setRotation")(js.undefined)
        ret
    }
    @scala.inline
    def withSetSectors(value: /* sectors */ js.UndefOr[Array] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setSectors")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetSectors: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setSectors")(js.undefined)
        ret
    }
    @scala.inline
    def withSetTotalAngle(value: /* totalAngle */ js.UndefOr[js.Any] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setTotalAngle")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetTotalAngle: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setTotalAngle")(js.undefined)
        ret
    }
    @scala.inline
    def withSetValue(value: /* value */ js.UndefOr[Double] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setValue")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetValue: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setValue")(js.undefined)
        ret
    }
    @scala.inline
    def withSetWholeDisk(value: /* wholeDisk */ js.UndefOr[Boolean] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setWholeDisk")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutSetWholeDisk: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setWholeDisk")(js.undefined)
        ret
    }
    @scala.inline
    def withValue(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("value")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutValue: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("value")(js.undefined)
        ret
    }
    @scala.inline
    def withWholeDisk(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("wholeDisk")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutWholeDisk: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("wholeDisk")(js.undefined)
        ret
    }
  }
  
}

