package typingsSlinky.gatsby.mod

import org.scalablytyped.runtime.StringDictionary
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait WebpackPlugins
  extends /* key */ StringDictionary[js.Function] {
  var aggressiveMerging: js.Function = js.native
  var aggressiveSplitting: js.Function = js.native
  var automaticPrefetch: js.Function = js.native
  var banner: js.Function = js.native
  var cache: js.Function = js.native
  var chunkModuleIdRange: js.Function = js.native
  var contextReplacement: js.Function = js.native
  var dedupe: js.Function = js.native
  var define: js.Function = js.native
  var dll: js.Function = js.native
  var dllReference: js.Function = js.native
  var environment: js.Function = js.native
  var evalDevToolModule: js.Function = js.native
  var evalSourceMapDevTool: js.Function = js.native
  var extendedAPI: js.Function = js.native
  var externals: js.Function = js.native
  var extractText: js.Function = js.native
  var hashedModuleIds: js.Function = js.native
  var hotModuleReplacement: js.Function = js.native
  var ignore: js.Function = js.native
  var jsonpTemplate: js.Function = js.native
  var libraryTemplate: js.Function = js.native
  var limitChunkCount: js.Function = js.native
  var loaderOptions: js.Function = js.native
  var loaderTarget: js.Function = js.native
  var memoryOutputFile: js.Function = js.native
  var minChunkSize: js.Function = js.native
  var minifyCss: js.Function = js.native
  var minifyJs: js.Function = js.native
  var moduleConcatenation: js.Function = js.native
  var moduleFilenameH: js.Function = js.native
  var moment: js.Function = js.native
  var namedChunks: js.Function = js.native
  var namedModules: js.Function = js.native
  var newWatching: js.Function = js.native
  var noEmitOnErrors: js.Function = js.native
  var noErrors: js.Function = js.native
  var normalModuleReplacement: js.Function = js.native
  var occurrenceOrder: js.Function = js.native
  var prefetch: js.Function = js.native
  var progress: js.Function = js.native
  var provide: js.Function = js.native
  var setVarMainTemplate: js.Function = js.native
  var sourceMapDevTool: js.Function = js.native
  var splitChunks: js.Function = js.native
  var umdMainTemplate: js.Function = js.native
  var watchIgnore: js.Function = js.native
}

object WebpackPlugins {
  @scala.inline
  def apply(
    aggressiveMerging: js.Function,
    aggressiveSplitting: js.Function,
    automaticPrefetch: js.Function,
    banner: js.Function,
    cache: js.Function,
    chunkModuleIdRange: js.Function,
    contextReplacement: js.Function,
    dedupe: js.Function,
    define: js.Function,
    dll: js.Function,
    dllReference: js.Function,
    environment: js.Function,
    evalDevToolModule: js.Function,
    evalSourceMapDevTool: js.Function,
    extendedAPI: js.Function,
    externals: js.Function,
    extractText: js.Function,
    hashedModuleIds: js.Function,
    hotModuleReplacement: js.Function,
    ignore: js.Function,
    jsonpTemplate: js.Function,
    libraryTemplate: js.Function,
    limitChunkCount: js.Function,
    loaderOptions: js.Function,
    loaderTarget: js.Function,
    memoryOutputFile: js.Function,
    minChunkSize: js.Function,
    minifyCss: js.Function,
    minifyJs: js.Function,
    moduleConcatenation: js.Function,
    moduleFilenameH: js.Function,
    moment: js.Function,
    namedChunks: js.Function,
    namedModules: js.Function,
    newWatching: js.Function,
    noEmitOnErrors: js.Function,
    noErrors: js.Function,
    normalModuleReplacement: js.Function,
    occurrenceOrder: js.Function,
    prefetch: js.Function,
    progress: js.Function,
    provide: js.Function,
    setVarMainTemplate: js.Function,
    sourceMapDevTool: js.Function,
    splitChunks: js.Function,
    umdMainTemplate: js.Function,
    watchIgnore: js.Function
  ): WebpackPlugins = {
    val __obj = js.Dynamic.literal(aggressiveMerging = aggressiveMerging.asInstanceOf[js.Any], aggressiveSplitting = aggressiveSplitting.asInstanceOf[js.Any], automaticPrefetch = automaticPrefetch.asInstanceOf[js.Any], banner = banner.asInstanceOf[js.Any], cache = cache.asInstanceOf[js.Any], chunkModuleIdRange = chunkModuleIdRange.asInstanceOf[js.Any], contextReplacement = contextReplacement.asInstanceOf[js.Any], dedupe = dedupe.asInstanceOf[js.Any], define = define.asInstanceOf[js.Any], dll = dll.asInstanceOf[js.Any], dllReference = dllReference.asInstanceOf[js.Any], environment = environment.asInstanceOf[js.Any], evalDevToolModule = evalDevToolModule.asInstanceOf[js.Any], evalSourceMapDevTool = evalSourceMapDevTool.asInstanceOf[js.Any], extendedAPI = extendedAPI.asInstanceOf[js.Any], externals = externals.asInstanceOf[js.Any], extractText = extractText.asInstanceOf[js.Any], hashedModuleIds = hashedModuleIds.asInstanceOf[js.Any], hotModuleReplacement = hotModuleReplacement.asInstanceOf[js.Any], ignore = ignore.asInstanceOf[js.Any], jsonpTemplate = jsonpTemplate.asInstanceOf[js.Any], libraryTemplate = libraryTemplate.asInstanceOf[js.Any], limitChunkCount = limitChunkCount.asInstanceOf[js.Any], loaderOptions = loaderOptions.asInstanceOf[js.Any], loaderTarget = loaderTarget.asInstanceOf[js.Any], memoryOutputFile = memoryOutputFile.asInstanceOf[js.Any], minChunkSize = minChunkSize.asInstanceOf[js.Any], minifyCss = minifyCss.asInstanceOf[js.Any], minifyJs = minifyJs.asInstanceOf[js.Any], moduleConcatenation = moduleConcatenation.asInstanceOf[js.Any], moduleFilenameH = moduleFilenameH.asInstanceOf[js.Any], moment = moment.asInstanceOf[js.Any], namedChunks = namedChunks.asInstanceOf[js.Any], namedModules = namedModules.asInstanceOf[js.Any], newWatching = newWatching.asInstanceOf[js.Any], noEmitOnErrors = noEmitOnErrors.asInstanceOf[js.Any], noErrors = noErrors.asInstanceOf[js.Any], normalModuleReplacement = normalModuleReplacement.asInstanceOf[js.Any], occurrenceOrder = occurrenceOrder.asInstanceOf[js.Any], prefetch = prefetch.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], provide = provide.asInstanceOf[js.Any], setVarMainTemplate = setVarMainTemplate.asInstanceOf[js.Any], sourceMapDevTool = sourceMapDevTool.asInstanceOf[js.Any], splitChunks = splitChunks.asInstanceOf[js.Any], umdMainTemplate = umdMainTemplate.asInstanceOf[js.Any], watchIgnore = watchIgnore.asInstanceOf[js.Any])
    __obj.asInstanceOf[WebpackPlugins]
  }
  @scala.inline
  implicit class WebpackPluginsOps[Self <: WebpackPlugins] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withAggressiveMerging(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("aggressiveMerging")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withAggressiveSplitting(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("aggressiveSplitting")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withAutomaticPrefetch(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("automaticPrefetch")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withBanner(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("banner")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCache(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cache")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withChunkModuleIdRange(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("chunkModuleIdRange")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withContextReplacement(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("contextReplacement")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDedupe(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dedupe")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDefine(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("define")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDll(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dll")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDllReference(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dllReference")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withEnvironment(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("environment")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withEvalDevToolModule(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("evalDevToolModule")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withEvalSourceMapDevTool(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("evalSourceMapDevTool")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withExtendedAPI(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("extendedAPI")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withExternals(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("externals")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withExtractText(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("extractText")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withHashedModuleIds(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hashedModuleIds")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withHotModuleReplacement(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hotModuleReplacement")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withIgnore(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ignore")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withJsonpTemplate(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("jsonpTemplate")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLibraryTemplate(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("libraryTemplate")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLimitChunkCount(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("limitChunkCount")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLoaderOptions(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("loaderOptions")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLoaderTarget(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("loaderTarget")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withMemoryOutputFile(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("memoryOutputFile")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withMinChunkSize(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("minChunkSize")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withMinifyCss(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("minifyCss")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withMinifyJs(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("minifyJs")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withModuleConcatenation(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moduleConcatenation")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withModuleFilenameH(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moduleFilenameH")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withMoment(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moment")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withNamedChunks(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("namedChunks")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withNamedModules(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("namedModules")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withNewWatching(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("newWatching")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withNoEmitOnErrors(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("noEmitOnErrors")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withNoErrors(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("noErrors")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withNormalModuleReplacement(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("normalModuleReplacement")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withOccurrenceOrder(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("occurrenceOrder")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withPrefetch(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("prefetch")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withProgress(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("progress")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withProvide(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("provide")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withSetVarMainTemplate(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setVarMainTemplate")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withSourceMapDevTool(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sourceMapDevTool")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withSplitChunks(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("splitChunks")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withUmdMainTemplate(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("umdMainTemplate")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withWatchIgnore(value: js.Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watchIgnore")(value.asInstanceOf[js.Any])
        ret
    }
  }
  
}

