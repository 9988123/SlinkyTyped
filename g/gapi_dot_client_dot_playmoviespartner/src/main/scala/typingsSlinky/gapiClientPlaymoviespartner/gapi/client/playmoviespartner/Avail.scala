package typingsSlinky.gapiClientPlaymoviespartner.gapi.client.playmoviespartner

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait Avail extends js.Object {
  /**
    * Other identifier referring to the Edit, as defined by partner.
    * Example: "GOOGLER_2006"
    */
  var altId: js.UndefOr[String] = js.native
  /**
    * ID internally generated by Google to uniquely identify an Avail.
    * Not part of EMA Specs.
    */
  var availId: js.UndefOr[String] = js.native
  /**
    * Communicating an exempt category as defined by FCC regulations.
    * It is not required for non-US Avails.
    * Example: "1"
    */
  var captionExemption: js.UndefOr[String] = js.native
  /** Communicating if caption file will be delivered. */
  var captionIncluded: js.UndefOr[Boolean] = js.native
  /**
    * Title Identifier. This should be the Title Level EIDR.
    * Example: "10.5240/1489-49A2-3956-4B2D-FE16-5".
    */
  var contentId: js.UndefOr[String] = js.native
  /**
    * The name of the studio that owns the Edit referred in the Avail.
    * This is the equivalent of `studio_name` in other resources, but it follows
    * the EMA nomenclature.
    * Example: "Google Films".
    */
  var displayName: js.UndefOr[String] = js.native
  /**
    * Manifestation Identifier. This should be the Manifestation
    * Level EIDR.
    * Example: "10.2340/1489-49A2-3956-4B2D-FE16-7"
    */
  var encodeId: js.UndefOr[String] = js.native
  /**
    * End of term in YYYY-MM-DD format in the timezone of the country
    * of the Avail.
    * "Open" if no end date is available.
    * Example: "2019-02-17"
    */
  var end: js.UndefOr[String] = js.native
  /**
    * Other identifier referring to the episode, as defined by partner.
    * Only available on TV avails.
    * Example: "rs_googlers_s1_3".
    */
  var episodeAltId: js.UndefOr[String] = js.native
  /**
    * The number assigned to the episode within a season.
    * Only available on TV Avails.
    * Example: "3".
    */
  var episodeNumber: js.UndefOr[String] = js.native
  /**
    * OPTIONAL.TV Only. Title used by involved parties to refer to this episode.
    * Only available on TV Avails.
    * Example: "Coding at Google".
    */
  var episodeTitleInternalAlias: js.UndefOr[String] = js.native
  /** Indicates the format profile covered by the transaction. */
  var formatProfile: js.UndefOr[String] = js.native
  /** Type of transaction. */
  var licenseType: js.UndefOr[String] = js.native
  /**
    * Name of the post-production houses that manage the Avail.
    * Not part of EMA Specs.
    */
  var pphNames: js.UndefOr[js.Array[String]] = js.native
  /**
    * Type of pricing that should be applied to this Avail
    * based on how the partner classify them.
    * Example: "Tier", "WSP", "SRP", or "Category".
    */
  var priceType: js.UndefOr[String] = js.native
  /**
    * Value to be applied to the pricing type.
    * Example: "4" or "2.99"
    */
  var priceValue: js.UndefOr[String] = js.native
  /**
    * Edit Identifier. This should be the Edit Level EIDR.
    * Example: "10.2340/1489-49A2-3956-4B2D-FE16-6"
    */
  var productId: js.UndefOr[String] = js.native
  /**
    * Value representing the rating reason.
    * Rating reasons should be formatted as per
    * [EMA ratings spec](http://www.movielabs.com/md/ratings/)
    * and comma-separated for inclusion of multiple reasons.
    * Example: "L, S, V"
    */
  var ratingReason: js.UndefOr[String] = js.native
  /**
    * Rating system applied to the version of title within territory
    * of Avail.
    * Rating systems should be formatted as per
    * [EMA ratings spec](http://www.movielabs.com/md/ratings/)
    * Example: "MPAA"
    */
  var ratingSystem: js.UndefOr[String] = js.native
  /**
    * Value representing the rating.
    * Ratings should be formatted as per http://www.movielabs.com/md/ratings/
    * Example: "PG"
    */
  var ratingValue: js.UndefOr[String] = js.native
  /**
    * Release date of the Title in earliest released territory.
    * Typically it is just the year, but it is free-form as per EMA spec.
    * Examples: "1979", "Oct 2014"
    */
  var releaseDate: js.UndefOr[String] = js.native
  /**
    * Other identifier referring to the season, as defined by partner.
    * Only available on TV avails.
    * Example: "rs_googlers_s1".
    */
  var seasonAltId: js.UndefOr[String] = js.native
  /**
    * The number assigned to the season within a series.
    * Only available on TV Avails.
    * Example: "1".
    */
  var seasonNumber: js.UndefOr[String] = js.native
  /**
    * Title used by involved parties to refer to this season.
    * Only available on TV Avails.
    * Example: "Googlers, The".
    */
  var seasonTitleInternalAlias: js.UndefOr[String] = js.native
  /**
    * Other identifier referring to the series, as defined by partner.
    * Only available on TV avails.
    * Example: "rs_googlers".
    */
  var seriesAltId: js.UndefOr[String] = js.native
  /**
    * Title used by involved parties to refer to this series.
    * Only available on TV Avails.
    * Example: "Googlers, The".
    */
  var seriesTitleInternalAlias: js.UndefOr[String] = js.native
  /**
    * Start of term in YYYY-MM-DD format in the timezone of the
    * country of the Avail.
    * Example: "2013-05-14".
    */
  var start: js.UndefOr[String] = js.native
  /**
    * Spoken language of the intended audience.
    * Language shall be encoded in accordance with RFC 5646.
    * Example: "fr".
    */
  var storeLanguage: js.UndefOr[String] = js.native
  /**
    * First date an Edit could be publically announced as becoming
    * available at a specific future date in territory of Avail.
    * &#42;Not&#42; the Avail start date or pre-order start date.
    * Format is YYYY-MM-DD.
    * Only available for pre-orders.
    * Example: "2012-12-10"
    */
  var suppressionLiftDate: js.UndefOr[String] = js.native
  /**
    * ISO 3166-1 alpha-2 country code for the country or territory
    * of this Avail.
    * For Avails, we use Territory in lieu of Country to comply with
    * EMA specifications.
    * But please note that Territory and Country identify the same thing.
    * Example: "US".
    */
  var territory: js.UndefOr[String] = js.native
  /**
    * Title used by involved parties to refer to this content.
    * Example: "Googlers, The".
    * Only available on Movie Avails.
    */
  var titleInternalAlias: js.UndefOr[String] = js.native
  /**
    * Google-generated ID identifying the video linked to this Avail, once
    * delivered.
    * Not part of EMA Specs.
    * Example: 'gtry456_xc'
    */
  var videoId: js.UndefOr[String] = js.native
  /** Work type as enumerated in EMA. */
  var workType: js.UndefOr[String] = js.native
}

object Avail {
  @scala.inline
  def apply(): Avail = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[Avail]
  }
  @scala.inline
  implicit class AvailOps[Self <: Avail] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withAltId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("altId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAltId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("altId")(js.undefined)
        ret
    }
    @scala.inline
    def withAvailId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("availId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAvailId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("availId")(js.undefined)
        ret
    }
    @scala.inline
    def withCaptionExemption(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("captionExemption")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCaptionExemption: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("captionExemption")(js.undefined)
        ret
    }
    @scala.inline
    def withCaptionIncluded(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("captionIncluded")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCaptionIncluded: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("captionIncluded")(js.undefined)
        ret
    }
    @scala.inline
    def withContentId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("contentId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutContentId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("contentId")(js.undefined)
        ret
    }
    @scala.inline
    def withDisplayName(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("displayName")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDisplayName: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("displayName")(js.undefined)
        ret
    }
    @scala.inline
    def withEncodeId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("encodeId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEncodeId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("encodeId")(js.undefined)
        ret
    }
    @scala.inline
    def withEnd(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("end")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEnd: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("end")(js.undefined)
        ret
    }
    @scala.inline
    def withEpisodeAltId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("episodeAltId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEpisodeAltId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("episodeAltId")(js.undefined)
        ret
    }
    @scala.inline
    def withEpisodeNumber(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("episodeNumber")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEpisodeNumber: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("episodeNumber")(js.undefined)
        ret
    }
    @scala.inline
    def withEpisodeTitleInternalAlias(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("episodeTitleInternalAlias")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEpisodeTitleInternalAlias: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("episodeTitleInternalAlias")(js.undefined)
        ret
    }
    @scala.inline
    def withFormatProfile(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("formatProfile")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutFormatProfile: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("formatProfile")(js.undefined)
        ret
    }
    @scala.inline
    def withLicenseType(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("licenseType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLicenseType: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("licenseType")(js.undefined)
        ret
    }
    @scala.inline
    def withPphNames(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("pphNames")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPphNames: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("pphNames")(js.undefined)
        ret
    }
    @scala.inline
    def withPriceType(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("priceType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPriceType: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("priceType")(js.undefined)
        ret
    }
    @scala.inline
    def withPriceValue(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("priceValue")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPriceValue: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("priceValue")(js.undefined)
        ret
    }
    @scala.inline
    def withProductId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("productId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutProductId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("productId")(js.undefined)
        ret
    }
    @scala.inline
    def withRatingReason(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ratingReason")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRatingReason: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ratingReason")(js.undefined)
        ret
    }
    @scala.inline
    def withRatingSystem(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ratingSystem")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRatingSystem: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ratingSystem")(js.undefined)
        ret
    }
    @scala.inline
    def withRatingValue(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ratingValue")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRatingValue: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ratingValue")(js.undefined)
        ret
    }
    @scala.inline
    def withReleaseDate(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("releaseDate")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutReleaseDate: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("releaseDate")(js.undefined)
        ret
    }
    @scala.inline
    def withSeasonAltId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seasonAltId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSeasonAltId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seasonAltId")(js.undefined)
        ret
    }
    @scala.inline
    def withSeasonNumber(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seasonNumber")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSeasonNumber: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seasonNumber")(js.undefined)
        ret
    }
    @scala.inline
    def withSeasonTitleInternalAlias(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seasonTitleInternalAlias")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSeasonTitleInternalAlias: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seasonTitleInternalAlias")(js.undefined)
        ret
    }
    @scala.inline
    def withSeriesAltId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seriesAltId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSeriesAltId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seriesAltId")(js.undefined)
        ret
    }
    @scala.inline
    def withSeriesTitleInternalAlias(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seriesTitleInternalAlias")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSeriesTitleInternalAlias: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("seriesTitleInternalAlias")(js.undefined)
        ret
    }
    @scala.inline
    def withStart(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("start")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutStart: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("start")(js.undefined)
        ret
    }
    @scala.inline
    def withStoreLanguage(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("storeLanguage")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutStoreLanguage: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("storeLanguage")(js.undefined)
        ret
    }
    @scala.inline
    def withSuppressionLiftDate(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("suppressionLiftDate")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSuppressionLiftDate: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("suppressionLiftDate")(js.undefined)
        ret
    }
    @scala.inline
    def withTerritory(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("territory")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTerritory: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("territory")(js.undefined)
        ret
    }
    @scala.inline
    def withTitleInternalAlias(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("titleInternalAlias")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTitleInternalAlias: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("titleInternalAlias")(js.undefined)
        ret
    }
    @scala.inline
    def withVideoId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("videoId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutVideoId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("videoId")(js.undefined)
        ret
    }
    @scala.inline
    def withWorkType(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("workType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutWorkType: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("workType")(js.undefined)
        ret
    }
  }
  
}

