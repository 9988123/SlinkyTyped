package typingsSlinky.googleapis.dataprocV1beta2Mod.dataprocV1beta2

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * Specifies Kerberos related configuration.
  */
@js.native
trait SchemaKerberosConfig extends js.Object {
  /**
    * Optional. The admin server (IP or hostname) for the remote trusted realm
    * in a cross realm trust relationship.
    */
  var crossRealmTrustAdminServer: js.UndefOr[String] = js.native
  /**
    * Optional. The KDC (IP or hostname) for the remote trusted realm in a
    * cross realm trust relationship.
    */
  var crossRealmTrustKdc: js.UndefOr[String] = js.native
  /**
    * Optional. The remote realm the Dataproc on-cluster KDC will trust, should
    * the user enable cross realm trust.
    */
  var crossRealmTrustRealm: js.UndefOr[String] = js.native
  /**
    * Optional. The GCS uri of a KMS encrypted file containing the shared
    * password between the on-cluster Kerberos realm and the remote trusted
    * realm, in a cross realm trust relationship.
    */
  var crossRealmTrustSharedPasswordUri: js.UndefOr[String] = js.native
  /**
    * Optional. Flag to indicate whether to Kerberize the cluster.
    */
  var enableKerberos: js.UndefOr[Boolean] = js.native
  /**
    * Optional. The GCS uri of a KMS encrypted file containing the master key
    * of the KDC database.
    */
  var kdcDbKeyUri: js.UndefOr[String] = js.native
  /**
    * Optional. The GCS uri of a KMS encrypted file containing the password to
    * the user provided key. For the self-signed certificate, this password is
    * generated by Dataproc.
    */
  var keyPasswordUri: js.UndefOr[String] = js.native
  /**
    * Optional. The GCS uri of a KMS encrypted file containing the password to
    * the user provided keystore. For the self-signed certificate, this
    * password is generated by Dataproc.
    */
  var keystorePasswordUri: js.UndefOr[String] = js.native
  /**
    * Optional. The GCS uri of the keystore file used for SSL encryption. If
    * not provided, Dataproc will provide a self-signed certificate.
    */
  var keystoreUri: js.UndefOr[String] = js.native
  /**
    * Required. The uri of the KMS key used to encrypt various sensitive files.
    */
  var kmsKeyUri: js.UndefOr[String] = js.native
  /**
    * Required. The GCS uri of a KMS encrypted file containing the root
    * principal password.
    */
  var rootPrincipalPasswordUri: js.UndefOr[String] = js.native
  /**
    * Optional. The lifetime of the ticket granting ticket, in hours. If not
    * specified, or user specifies 0, then default value 10 will be used.
    */
  var tgtLifetimeHours: js.UndefOr[Double] = js.native
  /**
    * Optional. The GCS uri of a KMS encrypted file containing the password to
    * the user provided truststore. For the self-signed certificate, this
    * password is generated by Dataproc.
    */
  var truststorePasswordUri: js.UndefOr[String] = js.native
  /**
    * Optional. The GCS uri of the truststore file used for SSL encryption. If
    * not provided, Dataproc will provide a self-signed certificate.
    */
  var truststoreUri: js.UndefOr[String] = js.native
}

object SchemaKerberosConfig {
  @scala.inline
  def apply(): SchemaKerberosConfig = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[SchemaKerberosConfig]
  }
  @scala.inline
  implicit class SchemaKerberosConfigOps[Self <: SchemaKerberosConfig] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withCrossRealmTrustAdminServer(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("crossRealmTrustAdminServer")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCrossRealmTrustAdminServer: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("crossRealmTrustAdminServer")(js.undefined)
        ret
    }
    @scala.inline
    def withCrossRealmTrustKdc(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("crossRealmTrustKdc")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCrossRealmTrustKdc: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("crossRealmTrustKdc")(js.undefined)
        ret
    }
    @scala.inline
    def withCrossRealmTrustRealm(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("crossRealmTrustRealm")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCrossRealmTrustRealm: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("crossRealmTrustRealm")(js.undefined)
        ret
    }
    @scala.inline
    def withCrossRealmTrustSharedPasswordUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("crossRealmTrustSharedPasswordUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCrossRealmTrustSharedPasswordUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("crossRealmTrustSharedPasswordUri")(js.undefined)
        ret
    }
    @scala.inline
    def withEnableKerberos(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("enableKerberos")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEnableKerberos: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("enableKerberos")(js.undefined)
        ret
    }
    @scala.inline
    def withKdcDbKeyUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("kdcDbKeyUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutKdcDbKeyUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("kdcDbKeyUri")(js.undefined)
        ret
    }
    @scala.inline
    def withKeyPasswordUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("keyPasswordUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutKeyPasswordUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("keyPasswordUri")(js.undefined)
        ret
    }
    @scala.inline
    def withKeystorePasswordUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("keystorePasswordUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutKeystorePasswordUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("keystorePasswordUri")(js.undefined)
        ret
    }
    @scala.inline
    def withKeystoreUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("keystoreUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutKeystoreUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("keystoreUri")(js.undefined)
        ret
    }
    @scala.inline
    def withKmsKeyUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("kmsKeyUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutKmsKeyUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("kmsKeyUri")(js.undefined)
        ret
    }
    @scala.inline
    def withRootPrincipalPasswordUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("rootPrincipalPasswordUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRootPrincipalPasswordUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("rootPrincipalPasswordUri")(js.undefined)
        ret
    }
    @scala.inline
    def withTgtLifetimeHours(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tgtLifetimeHours")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTgtLifetimeHours: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tgtLifetimeHours")(js.undefined)
        ret
    }
    @scala.inline
    def withTruststorePasswordUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("truststorePasswordUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTruststorePasswordUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("truststorePasswordUri")(js.undefined)
        ret
    }
    @scala.inline
    def withTruststoreUri(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("truststoreUri")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTruststoreUri: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("truststoreUri")(js.undefined)
        ret
    }
  }
  
}

