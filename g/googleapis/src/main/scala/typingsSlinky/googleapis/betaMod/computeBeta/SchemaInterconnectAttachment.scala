package typingsSlinky.googleapis.betaMod.computeBeta

import org.scalablytyped.runtime.StringDictionary
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * Represents an InterconnectAttachment (VLAN attachment) resource. For more
  * information, see  Creating VLAN Attachments. (== resource_for
  * beta.interconnectAttachments ==) (== resource_for
  * v1.interconnectAttachments ==)
  */
@js.native
trait SchemaInterconnectAttachment extends js.Object {
  /**
    * Determines whether this Attachment will carry packets. Not present for
    * PARTNER_PROVIDER.
    */
  var adminEnabled: js.UndefOr[Boolean] = js.native
  /**
    * Provisioned bandwidth capacity for the interconnectAttachment. Can be set
    * by the partner to update the customer&#39;s provisioned bandwidth. Output
    * only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED.
    */
  var bandwidth: js.UndefOr[String] = js.native
  /**
    * Up to 16 candidate prefixes that can be used to restrict the allocation
    * of cloudRouterIpAddress and customerRouterIpAddress for this attachment.
    * All prefixes must be within link-local address space (169.254.0.0/16) and
    * must be /29 or shorter (/28, /27, etc). Google will attempt to select an
    * unused /29 from the supplied candidate prefix(es). The request will fail
    * if all possible /29s are in use on Google?s edge. If not supplied, Google
    * will randomly select an unused /29 from all of link-local space.
    */
  var candidateSubnets: js.UndefOr[js.Array[String]] = js.native
  /**
    * [Output Only] IPv4 address + prefix length to be configured on Cloud
    * Router Interface for this interconnect attachment.
    */
  var cloudRouterIpAddress: js.UndefOr[String] = js.native
  /**
    * [Output Only] Creation timestamp in RFC3339 text format.
    */
  var creationTimestamp: js.UndefOr[String] = js.native
  /**
    * [Output Only] IPv4 address + prefix length to be configured on the
    * customer router subinterface for this interconnect attachment.
    */
  var customerRouterIpAddress: js.UndefOr[String] = js.native
  /**
    * An optional description of this resource.
    */
  var description: js.UndefOr[String] = js.native
  /**
    * Desired availability domain for the attachment. Only available for type
    * PARTNER, at creation time. For improved reliability, customers should
    * configure a pair of attachments with one per availability domain. The
    * selected availability domain will be provided to the Partner via the
    * pairing key so that the provisioned circuit will lie in the specified
    * domain. If not specified, the value will default to
    * AVAILABILITY_DOMAIN_ANY.
    */
  var edgeAvailabilityDomain: js.UndefOr[String] = js.native
  /**
    * [Output Only] Google reference ID, to be used when raising support
    * tickets with Google or otherwise to debug backend connectivity issues.
    */
  var googleReferenceId: js.UndefOr[String] = js.native
  /**
    * [Output Only] The unique identifier for the resource. This identifier is
    * defined by the server.
    */
  var id: js.UndefOr[String] = js.native
  /**
    * URL of the underlying Interconnect object that this attachment&#39;s
    * traffic will traverse through.
    */
  var interconnect: js.UndefOr[String] = js.native
  /**
    * [Output Only] Type of the resource. Always compute#interconnectAttachment
    * for interconnect attachments.
    */
  var kind: js.UndefOr[String] = js.native
  /**
    * A fingerprint for the labels being applied to this
    * InterconnectAttachment, which is essentially a hash of the labels set
    * used for optimistic locking. The fingerprint is initially generated by
    * Compute Engine and changes after every request to modify or update
    * labels. You must always provide an up-to-date fingerprint hash in order
    * to update or change labels, otherwise the request will fail with error
    * 412 conditionNotMet.  To see the latest fingerprint, make a get() request
    * to retrieve an InterconnectAttachment.
    */
  var labelFingerprint: js.UndefOr[String] = js.native
  /**
    * Labels to apply to this InterconnectAttachment resource. These can be
    * later modified by the setLabels method. Each label key/value must comply
    * with RFC1035. Label values may be empty.
    */
  var labels: js.UndefOr[StringDictionary[String]] = js.native
  /**
    * Name of the resource. Provided by the client when the resource is
    * created. The name must be 1-63 characters long, and comply with RFC1035.
    * Specifically, the name must be 1-63 characters long and match the regular
    * expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
    * must be a lowercase letter, and all following characters must be a dash,
    * lowercase letter, or digit, except the last character, which cannot be a
    * dash.
    */
  var name: js.UndefOr[String] = js.native
  /**
    * [Output Only] The current status of whether or not this interconnect
    * attachment is functional.
    */
  var operationalStatus: js.UndefOr[String] = js.native
  /**
    * [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not
    * present for DEDICATED]. The opaque identifier of an PARTNER attachment
    * used to initiate provisioning with a selected partner. Of the form
    * &quot;XXXXX/region/domain&quot;
    */
  var pairingKey: js.UndefOr[String] = js.native
  /**
    * Optional BGP ASN for the router that should be supplied by a layer 3
    * Partner if they configured BGP on behalf of the customer. Output only for
    * PARTNER type, input only for PARTNER_PROVIDER, not available for
    * DEDICATED.
    */
  var partnerAsn: js.UndefOr[String] = js.native
  /**
    * Informational metadata about Partner attachments from Partners to display
    * to customers. Output only for for PARTNER type, mutable for
    * PARTNER_PROVIDER, not available for DEDICATED.
    */
  var partnerMetadata: js.UndefOr[SchemaInterconnectAttachmentPartnerMetadata] = js.native
  /**
    * [Output Only] Information specific to an InterconnectAttachment. This
    * property is populated if the interconnect that this is attached to is of
    * type DEDICATED.
    */
  var privateInterconnectInfo: js.UndefOr[SchemaInterconnectAttachmentPrivateInfo] = js.native
  /**
    * [Output Only] URL of the region where the regional interconnect
    * attachment resides. You must specify this field as part of the HTTP
    * request URL. It is not settable as a field in the request body.
    */
  var region: js.UndefOr[String] = js.native
  /**
    * URL of the Cloud Router to be used for dynamic routing. This router must
    * be in the same region as this InterconnectAttachment. The
    * InterconnectAttachment will automatically connect the Interconnect to the
    * network &amp; region within which the Cloud Router is configured.
    */
  var router: js.UndefOr[String] = js.native
  /**
    * [Output Only] Server-defined URL for the resource.
    */
  var selfLink: js.UndefOr[String] = js.native
  /**
    * [Output Only] The current state of this attachment&#39;s functionality.
    */
  var state: js.UndefOr[String] = js.native
  var `type`: js.UndefOr[String] = js.native
  /**
    * The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only
    * specified at creation time.
    */
  var vlanTag8021q: js.UndefOr[Double] = js.native
}

object SchemaInterconnectAttachment {
  @scala.inline
  def apply(): SchemaInterconnectAttachment = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[SchemaInterconnectAttachment]
  }
  @scala.inline
  implicit class SchemaInterconnectAttachmentOps[Self <: SchemaInterconnectAttachment] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withAdminEnabled(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("adminEnabled")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAdminEnabled: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("adminEnabled")(js.undefined)
        ret
    }
    @scala.inline
    def withBandwidth(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("bandwidth")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutBandwidth: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("bandwidth")(js.undefined)
        ret
    }
    @scala.inline
    def withCandidateSubnets(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("candidateSubnets")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCandidateSubnets: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("candidateSubnets")(js.undefined)
        ret
    }
    @scala.inline
    def withCloudRouterIpAddress(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cloudRouterIpAddress")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCloudRouterIpAddress: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cloudRouterIpAddress")(js.undefined)
        ret
    }
    @scala.inline
    def withCreationTimestamp(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("creationTimestamp")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCreationTimestamp: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("creationTimestamp")(js.undefined)
        ret
    }
    @scala.inline
    def withCustomerRouterIpAddress(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("customerRouterIpAddress")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCustomerRouterIpAddress: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("customerRouterIpAddress")(js.undefined)
        ret
    }
    @scala.inline
    def withDescription(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("description")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDescription: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("description")(js.undefined)
        ret
    }
    @scala.inline
    def withEdgeAvailabilityDomain(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("edgeAvailabilityDomain")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEdgeAvailabilityDomain: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("edgeAvailabilityDomain")(js.undefined)
        ret
    }
    @scala.inline
    def withGoogleReferenceId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("googleReferenceId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGoogleReferenceId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("googleReferenceId")(js.undefined)
        ret
    }
    @scala.inline
    def withId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("id")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("id")(js.undefined)
        ret
    }
    @scala.inline
    def withInterconnect(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("interconnect")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutInterconnect: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("interconnect")(js.undefined)
        ret
    }
    @scala.inline
    def withKind(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("kind")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutKind: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("kind")(js.undefined)
        ret
    }
    @scala.inline
    def withLabelFingerprint(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("labelFingerprint")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLabelFingerprint: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("labelFingerprint")(js.undefined)
        ret
    }
    @scala.inline
    def withLabels(value: StringDictionary[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("labels")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLabels: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("labels")(js.undefined)
        ret
    }
    @scala.inline
    def withName(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("name")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutName: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("name")(js.undefined)
        ret
    }
    @scala.inline
    def withOperationalStatus(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("operationalStatus")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutOperationalStatus: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("operationalStatus")(js.undefined)
        ret
    }
    @scala.inline
    def withPairingKey(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("pairingKey")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPairingKey: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("pairingKey")(js.undefined)
        ret
    }
    @scala.inline
    def withPartnerAsn(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("partnerAsn")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPartnerAsn: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("partnerAsn")(js.undefined)
        ret
    }
    @scala.inline
    def withPartnerMetadata(value: SchemaInterconnectAttachmentPartnerMetadata): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("partnerMetadata")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPartnerMetadata: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("partnerMetadata")(js.undefined)
        ret
    }
    @scala.inline
    def withPrivateInterconnectInfo(value: SchemaInterconnectAttachmentPrivateInfo): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("privateInterconnectInfo")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPrivateInterconnectInfo: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("privateInterconnectInfo")(js.undefined)
        ret
    }
    @scala.inline
    def withRegion(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("region")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRegion: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("region")(js.undefined)
        ret
    }
    @scala.inline
    def withRouter(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("router")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRouter: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("router")(js.undefined)
        ret
    }
    @scala.inline
    def withSelfLink(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("selfLink")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSelfLink: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("selfLink")(js.undefined)
        ret
    }
    @scala.inline
    def withState(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("state")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutState: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("state")(js.undefined)
        ret
    }
    @scala.inline
    def withType(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("type")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutType: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("type")(js.undefined)
        ret
    }
    @scala.inline
    def withVlanTag8021q(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("vlanTag8021q")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutVlanTag8021q: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("vlanTag8021q")(js.undefined)
        ret
    }
  }
  
}

