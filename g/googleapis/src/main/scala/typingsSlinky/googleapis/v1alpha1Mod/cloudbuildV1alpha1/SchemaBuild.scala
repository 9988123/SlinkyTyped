package typingsSlinky.googleapis.v1alpha1Mod.cloudbuildV1alpha1

import org.scalablytyped.runtime.StringDictionary
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * A build resource in the Cloud Build API.  At a high level, a `Build`
  * describes where to find source code, how to build it (for example, the
  * builder image to run on the source), and where to store the built
  * artifacts.  Fields can include the following variables, which will be
  * expanded when the build is created:  - $PROJECT_ID: the project ID of the
  * build. - $BUILD_ID: the autogenerated ID of the build. - $REPO_NAME: the
  * source repository name specified by RepoSource. - $BRANCH_NAME: the branch
  * name specified by RepoSource. - $TAG_NAME: the tag name specified by
  * RepoSource. - $REVISION_ID or $COMMIT_SHA: the commit SHA specified by
  * RepoSource or   resolved from the specified branch or tag. - $SHORT_SHA:
  * first 7 characters of $REVISION_ID or $COMMIT_SHA.
  */
@js.native
trait SchemaBuild extends js.Object {
  /**
    * Artifacts produced by the build that should be uploaded upon successful
    * completion of all build steps.
    */
  var artifacts: js.UndefOr[SchemaArtifacts] = js.native
  /**
    * Output only. The ID of the `BuildTrigger` that triggered this build, if
    * it was triggered automatically.
    */
  var buildTriggerId: js.UndefOr[String] = js.native
  /**
    * Output only. Time at which the request to create the build was received.
    */
  var createTime: js.UndefOr[String] = js.native
  /**
    * Output only. Time at which execution of the build was finished.  The
    * difference between finish_time and start_time is the duration of the
    * build&#39;s execution.
    */
  var finishTime: js.UndefOr[String] = js.native
  /**
    * Output only. Unique identifier of the build.
    */
  var id: js.UndefOr[String] = js.native
  /**
    * A list of images to be pushed upon the successful completion of all build
    * steps.  The images are pushed using the builder service account&#39;s
    * credentials.  The digests of the pushed images will be stored in the
    * `Build` resource&#39;s results field.  If any of the images fail to be
    * pushed, the build status is marked `FAILURE`.
    */
  var images: js.UndefOr[js.Array[String]] = js.native
  /**
    * Output only. URL to logs for this build in Google Cloud Console.
    */
  var logUrl: js.UndefOr[String] = js.native
  /**
    * Google Cloud Storage bucket where logs should be written (see [Bucket
    * Name
    * Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    * Logs file names will be of the format
    * `${logs_bucket}/log-${build_id}.txt`.
    */
  var logsBucket: js.UndefOr[String] = js.native
  /**
    * Special options for this build.
    */
  var options: js.UndefOr[SchemaBuildOptions] = js.native
  /**
    * Output only. ID of the project.
    */
  var projectId: js.UndefOr[String] = js.native
  /**
    * Output only. Results of the build.
    */
  var results: js.UndefOr[SchemaResults] = js.native
  /**
    * Secrets to decrypt using Cloud Key Management Service.
    */
  var secrets: js.UndefOr[js.Array[SchemaSecret]] = js.native
  /**
    * The location of the source files to build.
    */
  var source: js.UndefOr[SchemaSource] = js.native
  /**
    * Output only. A permanent fixed identifier for source.
    */
  var sourceProvenance: js.UndefOr[SchemaSourceProvenance] = js.native
  /**
    * Output only. Time at which execution of the build was started.
    */
  var startTime: js.UndefOr[String] = js.native
  /**
    * Output only. Status of the build.
    */
  var status: js.UndefOr[String] = js.native
  /**
    * Output only. Customer-readable message about the current status.
    */
  var statusDetail: js.UndefOr[String] = js.native
  /**
    * Required. The operations to be performed on the workspace.
    */
  var steps: js.UndefOr[js.Array[SchemaBuildStep]] = js.native
  /**
    * Substitutions data for `Build` resource.
    */
  var substitutions: js.UndefOr[StringDictionary[String]] = js.native
  /**
    * Tags for annotation of a `Build`. These are not docker tags.
    */
  var tags: js.UndefOr[js.Array[String]] = js.native
  /**
    * Amount of time that this build should be allowed to run, to second
    * granularity. If this amount of time elapses, work on the build will cease
    * and the build status will be `TIMEOUT`.  Default time is ten minutes.
    */
  var timeout: js.UndefOr[String] = js.native
  /**
    * Output only. Stores timing information for phases of the build. Valid
    * keys are:  * BUILD: time to execute all build steps * PUSH: time to push
    * all specified images. * FETCHSOURCE: time to fetch source.  If the build
    * does not specify source or images, these keys will not be included.
    */
  var timing: js.UndefOr[StringDictionary[SchemaTimeSpan]] = js.native
}

object SchemaBuild {
  @scala.inline
  def apply(): SchemaBuild = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[SchemaBuild]
  }
  @scala.inline
  implicit class SchemaBuildOps[Self <: SchemaBuild] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withArtifacts(value: SchemaArtifacts): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("artifacts")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutArtifacts: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("artifacts")(js.undefined)
        ret
    }
    @scala.inline
    def withBuildTriggerId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("buildTriggerId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutBuildTriggerId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("buildTriggerId")(js.undefined)
        ret
    }
    @scala.inline
    def withCreateTime(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("createTime")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCreateTime: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("createTime")(js.undefined)
        ret
    }
    @scala.inline
    def withFinishTime(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("finishTime")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutFinishTime: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("finishTime")(js.undefined)
        ret
    }
    @scala.inline
    def withId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("id")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("id")(js.undefined)
        ret
    }
    @scala.inline
    def withImages(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("images")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutImages: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("images")(js.undefined)
        ret
    }
    @scala.inline
    def withLogUrl(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("logUrl")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLogUrl: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("logUrl")(js.undefined)
        ret
    }
    @scala.inline
    def withLogsBucket(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("logsBucket")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLogsBucket: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("logsBucket")(js.undefined)
        ret
    }
    @scala.inline
    def withOptions(value: SchemaBuildOptions): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("options")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutOptions: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("options")(js.undefined)
        ret
    }
    @scala.inline
    def withProjectId(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("projectId")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutProjectId: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("projectId")(js.undefined)
        ret
    }
    @scala.inline
    def withResults(value: SchemaResults): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("results")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutResults: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("results")(js.undefined)
        ret
    }
    @scala.inline
    def withSecrets(value: js.Array[SchemaSecret]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("secrets")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSecrets: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("secrets")(js.undefined)
        ret
    }
    @scala.inline
    def withSource(value: SchemaSource): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("source")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSource: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("source")(js.undefined)
        ret
    }
    @scala.inline
    def withSourceProvenance(value: SchemaSourceProvenance): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sourceProvenance")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSourceProvenance: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sourceProvenance")(js.undefined)
        ret
    }
    @scala.inline
    def withStartTime(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("startTime")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutStartTime: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("startTime")(js.undefined)
        ret
    }
    @scala.inline
    def withStatus(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("status")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutStatus: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("status")(js.undefined)
        ret
    }
    @scala.inline
    def withStatusDetail(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("statusDetail")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutStatusDetail: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("statusDetail")(js.undefined)
        ret
    }
    @scala.inline
    def withSteps(value: js.Array[SchemaBuildStep]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("steps")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSteps: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("steps")(js.undefined)
        ret
    }
    @scala.inline
    def withSubstitutions(value: StringDictionary[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("substitutions")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSubstitutions: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("substitutions")(js.undefined)
        ret
    }
    @scala.inline
    def withTags(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tags")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTags: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tags")(js.undefined)
        ret
    }
    @scala.inline
    def withTimeout(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timeout")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTimeout: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timeout")(js.undefined)
        ret
    }
    @scala.inline
    def withTiming(value: StringDictionary[SchemaTimeSpan]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timing")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTiming: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timing")(js.undefined)
        ret
    }
  }
  
}

