package typingsSlinky.gremlin.mod.process

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait Statics_[T /* <: GraphTraversal */] extends js.Object {
  def V(args: js.Any*): T = js.native
  def addE(args: js.Any*): T = js.native
  def addV(args: js.Any*): T = js.native
  def aggregate(args: js.Any*): T = js.native
  def and(args: js.Any*): T = js.native
  def as(args: js.Any*): T = js.native
  def barrier(args: js.Any*): T = js.native
  def both(args: js.Any*): T = js.native
  def bothE(args: js.Any*): T = js.native
  def bothV(args: js.Any*): T = js.native
  def branch(args: js.Any*): T = js.native
  def cap(args: js.Any*): T = js.native
  def choose(args: js.Any*): T = js.native
  def coalesce(args: js.Any*): T = js.native
  def coin(args: js.Any*): T = js.native
  def constant(args: js.Any*): T = js.native
  def count(args: js.Any*): T = js.native
  def cyclicPath(args: js.Any*): T = js.native
  def dedup(args: js.Any*): T = js.native
  def drop(args: js.Any*): T = js.native
  def elementMap(args: js.Any*): T = js.native
  def emit(args: js.Any*): T = js.native
  def filter(args: js.Any*): T = js.native
  def flatMap(args: js.Any*): T = js.native
  def fold(args: js.Any*): T = js.native
  def group(args: js.Any*): T = js.native
  def groupCount(args: js.Any*): T = js.native
  def has(args: js.Any*): T = js.native
  def hasId(args: js.Any*): T = js.native
  def hasKey(args: js.Any*): T = js.native
  def hasLabel(args: js.Any*): T = js.native
  def hasNot(args: js.Any*): T = js.native
  def hasValue(args: js.Any*): T = js.native
  def id(args: js.Any*): T = js.native
  def identity(args: js.Any*): T = js.native
  def inE(args: js.Any*): T = js.native
  def inV(args: js.Any*): T = js.native
  def in_(args: js.Any*): T = js.native
  def index(args: js.Any*): T = js.native
  def inject(args: js.Any*): T = js.native
  def is(args: js.Any*): T = js.native
  def key(args: js.Any*): T = js.native
  def label(args: js.Any*): T = js.native
  def limit(args: js.Any*): T = js.native
  def local(args: js.Any*): T = js.native
  def loops(args: js.Any*): T = js.native
  def map(args: js.Any*): T = js.native
  def `match`(args: js.Any*): T = js.native
  def math(args: js.Any*): T = js.native
  def max(args: js.Any*): T = js.native
  def mean(args: js.Any*): T = js.native
  def min(args: js.Any*): T = js.native
  def not(args: js.Any*): T = js.native
  def optional(args: js.Any*): T = js.native
  def or(args: js.Any*): T = js.native
  def order(args: js.Any*): T = js.native
  def otherV(args: js.Any*): T = js.native
  def out(args: js.Any*): T = js.native
  def outE(args: js.Any*): T = js.native
  def outV(args: js.Any*): T = js.native
  def path(args: js.Any*): T = js.native
  def project(args: js.Any*): T = js.native
  def properties(args: js.Any*): T = js.native
  def property(args: js.Any*): T = js.native
  def propertyMap(args: js.Any*): T = js.native
  def range(args: js.Any*): T = js.native
  def repeat(args: js.Any*): T = js.native
  def sack(args: js.Any*): T = js.native
  def sample(args: js.Any*): T = js.native
  def select(args: js.Any*): T = js.native
  def sideEffect(args: js.Any*): T = js.native
  def simplePath(args: js.Any*): T = js.native
  def skip(args: js.Any*): T = js.native
  def store(args: js.Any*): T = js.native
  def subgraph(args: js.Any*): T = js.native
  def sum(args: js.Any*): T = js.native
  def tail(args: js.Any*): T = js.native
  def timeLimit(args: js.Any*): T = js.native
  def times(args: js.Any*): T = js.native
  def to(args: js.Any*): T = js.native
  def toE(args: js.Any*): T = js.native
  def toV(args: js.Any*): T = js.native
  def tree(args: js.Any*): T = js.native
  def unfold(args: js.Any*): T = js.native
  def union(args: js.Any*): T = js.native
  def until(args: js.Any*): T = js.native
  def value(args: js.Any*): T = js.native
  def valueMap(args: js.Any*): T = js.native
  def values(args: js.Any*): T = js.native
  def where(args: js.Any*): T = js.native
}

object Statics_ {
  @scala.inline
  def apply[T](
    V: /* repeated */ js.Any => T,
    addE: /* repeated */ js.Any => T,
    addV: /* repeated */ js.Any => T,
    aggregate: /* repeated */ js.Any => T,
    and: /* repeated */ js.Any => T,
    as: /* repeated */ js.Any => T,
    barrier: /* repeated */ js.Any => T,
    both: /* repeated */ js.Any => T,
    bothE: /* repeated */ js.Any => T,
    bothV: /* repeated */ js.Any => T,
    branch: /* repeated */ js.Any => T,
    cap: /* repeated */ js.Any => T,
    choose: /* repeated */ js.Any => T,
    coalesce: /* repeated */ js.Any => T,
    coin: /* repeated */ js.Any => T,
    constant: /* repeated */ js.Any => T,
    count: /* repeated */ js.Any => T,
    cyclicPath: /* repeated */ js.Any => T,
    dedup: /* repeated */ js.Any => T,
    drop: /* repeated */ js.Any => T,
    elementMap: /* repeated */ js.Any => T,
    emit: /* repeated */ js.Any => T,
    filter: /* repeated */ js.Any => T,
    flatMap: /* repeated */ js.Any => T,
    fold: /* repeated */ js.Any => T,
    group: /* repeated */ js.Any => T,
    groupCount: /* repeated */ js.Any => T,
    has: /* repeated */ js.Any => T,
    hasId: /* repeated */ js.Any => T,
    hasKey: /* repeated */ js.Any => T,
    hasLabel: /* repeated */ js.Any => T,
    hasNot: /* repeated */ js.Any => T,
    hasValue: /* repeated */ js.Any => T,
    id: /* repeated */ js.Any => T,
    identity: /* repeated */ js.Any => T,
    inE: /* repeated */ js.Any => T,
    inV: /* repeated */ js.Any => T,
    in_ : /* repeated */ js.Any => T,
    index: /* repeated */ js.Any => T,
    inject: /* repeated */ js.Any => T,
    is: /* repeated */ js.Any => T,
    key: /* repeated */ js.Any => T,
    label: /* repeated */ js.Any => T,
    limit: /* repeated */ js.Any => T,
    local: /* repeated */ js.Any => T,
    loops: /* repeated */ js.Any => T,
    map: /* repeated */ js.Any => T,
    `match`: /* repeated */ js.Any => T,
    math: /* repeated */ js.Any => T,
    max: /* repeated */ js.Any => T,
    mean: /* repeated */ js.Any => T,
    min: /* repeated */ js.Any => T,
    not: /* repeated */ js.Any => T,
    optional: /* repeated */ js.Any => T,
    or: /* repeated */ js.Any => T,
    order: /* repeated */ js.Any => T,
    otherV: /* repeated */ js.Any => T,
    out: /* repeated */ js.Any => T,
    outE: /* repeated */ js.Any => T,
    outV: /* repeated */ js.Any => T,
    path: /* repeated */ js.Any => T,
    project: /* repeated */ js.Any => T,
    properties: /* repeated */ js.Any => T,
    property: /* repeated */ js.Any => T,
    propertyMap: /* repeated */ js.Any => T,
    range: /* repeated */ js.Any => T,
    repeat: /* repeated */ js.Any => T,
    sack: /* repeated */ js.Any => T,
    sample: /* repeated */ js.Any => T,
    select: /* repeated */ js.Any => T,
    sideEffect: /* repeated */ js.Any => T,
    simplePath: /* repeated */ js.Any => T,
    skip: /* repeated */ js.Any => T,
    store: /* repeated */ js.Any => T,
    subgraph: /* repeated */ js.Any => T,
    sum: /* repeated */ js.Any => T,
    tail: /* repeated */ js.Any => T,
    timeLimit: /* repeated */ js.Any => T,
    times: /* repeated */ js.Any => T,
    to: /* repeated */ js.Any => T,
    toE: /* repeated */ js.Any => T,
    toV: /* repeated */ js.Any => T,
    tree: /* repeated */ js.Any => T,
    unfold: /* repeated */ js.Any => T,
    union: /* repeated */ js.Any => T,
    until: /* repeated */ js.Any => T,
    value: /* repeated */ js.Any => T,
    valueMap: /* repeated */ js.Any => T,
    values: /* repeated */ js.Any => T,
    where: /* repeated */ js.Any => T
  ): Statics_[T] = {
    val __obj = js.Dynamic.literal(V = js.Any.fromFunction1(V), addE = js.Any.fromFunction1(addE), addV = js.Any.fromFunction1(addV), aggregate = js.Any.fromFunction1(aggregate), and = js.Any.fromFunction1(and), as = js.Any.fromFunction1(as), barrier = js.Any.fromFunction1(barrier), both = js.Any.fromFunction1(both), bothE = js.Any.fromFunction1(bothE), bothV = js.Any.fromFunction1(bothV), branch = js.Any.fromFunction1(branch), cap = js.Any.fromFunction1(cap), choose = js.Any.fromFunction1(choose), coalesce = js.Any.fromFunction1(coalesce), coin = js.Any.fromFunction1(coin), constant = js.Any.fromFunction1(constant), count = js.Any.fromFunction1(count), cyclicPath = js.Any.fromFunction1(cyclicPath), dedup = js.Any.fromFunction1(dedup), drop = js.Any.fromFunction1(drop), elementMap = js.Any.fromFunction1(elementMap), emit = js.Any.fromFunction1(emit), filter = js.Any.fromFunction1(filter), flatMap = js.Any.fromFunction1(flatMap), fold = js.Any.fromFunction1(fold), group = js.Any.fromFunction1(group), groupCount = js.Any.fromFunction1(groupCount), has = js.Any.fromFunction1(has), hasId = js.Any.fromFunction1(hasId), hasKey = js.Any.fromFunction1(hasKey), hasLabel = js.Any.fromFunction1(hasLabel), hasNot = js.Any.fromFunction1(hasNot), hasValue = js.Any.fromFunction1(hasValue), id = js.Any.fromFunction1(id), identity = js.Any.fromFunction1(identity), inE = js.Any.fromFunction1(inE), inV = js.Any.fromFunction1(inV), in_ = js.Any.fromFunction1(in_), index = js.Any.fromFunction1(index), inject = js.Any.fromFunction1(inject), is = js.Any.fromFunction1(is), key = js.Any.fromFunction1(key), label = js.Any.fromFunction1(label), limit = js.Any.fromFunction1(limit), local = js.Any.fromFunction1(local), loops = js.Any.fromFunction1(loops), map = js.Any.fromFunction1(map), math = js.Any.fromFunction1(math), max = js.Any.fromFunction1(max), mean = js.Any.fromFunction1(mean), min = js.Any.fromFunction1(min), not = js.Any.fromFunction1(not), optional = js.Any.fromFunction1(optional), or = js.Any.fromFunction1(or), order = js.Any.fromFunction1(order), otherV = js.Any.fromFunction1(otherV), out = js.Any.fromFunction1(out), outE = js.Any.fromFunction1(outE), outV = js.Any.fromFunction1(outV), path = js.Any.fromFunction1(path), project = js.Any.fromFunction1(project), properties = js.Any.fromFunction1(properties), property = js.Any.fromFunction1(property), propertyMap = js.Any.fromFunction1(propertyMap), range = js.Any.fromFunction1(range), repeat = js.Any.fromFunction1(repeat), sack = js.Any.fromFunction1(sack), sample = js.Any.fromFunction1(sample), select = js.Any.fromFunction1(select), sideEffect = js.Any.fromFunction1(sideEffect), simplePath = js.Any.fromFunction1(simplePath), skip = js.Any.fromFunction1(skip), store = js.Any.fromFunction1(store), subgraph = js.Any.fromFunction1(subgraph), sum = js.Any.fromFunction1(sum), tail = js.Any.fromFunction1(tail), timeLimit = js.Any.fromFunction1(timeLimit), times = js.Any.fromFunction1(times), to = js.Any.fromFunction1(to), toE = js.Any.fromFunction1(toE), toV = js.Any.fromFunction1(toV), tree = js.Any.fromFunction1(tree), unfold = js.Any.fromFunction1(unfold), union = js.Any.fromFunction1(union), until = js.Any.fromFunction1(until), value = js.Any.fromFunction1(value), valueMap = js.Any.fromFunction1(valueMap), values = js.Any.fromFunction1(values), where = js.Any.fromFunction1(where))
    __obj.updateDynamic("match")(js.Any.fromFunction1(`match`))
    __obj.asInstanceOf[Statics_[T]]
  }
  @scala.inline
  implicit class Statics_Ops[Self[t] <: Statics_[t], T] (val x: Self[T]) extends AnyVal {
    @scala.inline
    def duplicate: Self[T] = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self[T]]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self[T] with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self[T] with Other]
    @scala.inline
    def withV(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("V")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withAddE(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("addE")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withAddV(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("addV")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withAggregate(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("aggregate")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withAnd(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("and")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withAs(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("as")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withBarrier(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("barrier")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withBoth(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("both")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withBothE(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("bothE")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withBothV(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("bothV")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withBranch(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("branch")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withCap(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cap")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withChoose(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("choose")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withCoalesce(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coalesce")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withCoin(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coin")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withConstant(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("constant")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withCount(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("count")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withCyclicPath(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cyclicPath")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withDedup(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dedup")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withDrop(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("drop")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withElementMap(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("elementMap")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withEmit(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("emit")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withFilter(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("filter")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withFlatMap(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("flatMap")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withFold(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("fold")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withGroup(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("group")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withGroupCount(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("groupCount")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withHas(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("has")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withHasId(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hasId")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withHasKey(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hasKey")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withHasLabel(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hasLabel")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withHasNot(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hasNot")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withHasValue(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hasValue")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withId(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("id")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withIdentity(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("identity")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withInE(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("inE")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withInV(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("inV")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withIn_(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("in_")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withIndex(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("index")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withInject(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("inject")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withIs(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("is")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withKey(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("key")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withLabel(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("label")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withLimit(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("limit")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withLocal(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("local")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withLoops(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("loops")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withMap(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("map")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withMatch(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("match")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withMath(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("math")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withMax(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("max")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withMean(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("mean")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withMin(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("min")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withNot(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("not")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withOptional(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("optional")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withOr(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("or")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withOrder(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("order")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withOtherV(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("otherV")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withOut(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("out")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withOutE(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("outE")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withOutV(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("outV")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withPath(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("path")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withProject(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("project")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withProperties(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("properties")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withProperty(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("property")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withPropertyMap(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("propertyMap")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withRange(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("range")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withRepeat(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("repeat")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withSack(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sack")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withSample(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sample")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withSelect(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("select")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withSideEffect(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sideEffect")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withSimplePath(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("simplePath")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withSkip(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("skip")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withStore(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("store")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withSubgraph(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("subgraph")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withSum(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("sum")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withTail(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tail")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withTimeLimit(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timeLimit")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withTimes(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("times")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withTo(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("to")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withToE(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("toE")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withToV(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("toV")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withTree(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("tree")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withUnfold(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("unfold")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withUnion(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("union")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withUntil(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("until")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withValue(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("value")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withValueMap(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("valueMap")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withValues(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("values")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withWhere(value: /* repeated */ js.Any => T): Self[T] = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("where")(js.Any.fromFunction1(value))
        ret
    }
  }
  
}

