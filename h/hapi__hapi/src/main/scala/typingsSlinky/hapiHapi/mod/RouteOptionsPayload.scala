package typingsSlinky.hapiHapi.mod

import typingsSlinky.hapiHapi.AnonOutput
import typingsSlinky.hapiHapi.hapiHapiBooleans.`false`
import typingsSlinky.hapiHapi.hapiHapiStrings.gunzip
import typingsSlinky.hapiHapi.mod.Lifecycle.FailAction
import typingsSlinky.hapiHapi.mod.Lifecycle.ReturnValue
import typingsSlinky.hapiHapi.mod.Util.Dictionary
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait RouteOptionsPayload extends js.Object {
  /**
    * @default allows parsing of the following mime types:
    * * application/json
    * * application/ *+json
    * * application/octet-stream
    * * application/x-www-form-urlencoded
    * * multipart/form-data
    * * text/ *
    * A string or an array of strings with the allowed mime types for the endpoint. Use this settings to limit the set of allowed mime types. Note that allowing additional mime types not listed
    * above will not enable them to be parsed, and if parse is true, the request will result in an error response.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadallow)
    */
  var allow: js.UndefOr[String | js.Array[String]] = js.native
  /**
    * @default none.
    * An object where each key is a content-encoding name and each value is an object with the desired decoder settings. Note that encoder settings are set in compression.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadcompression)
    */
  var compression: js.UndefOr[Dictionary[PayloadCompressionDecoderSettings]] = js.native
  /**
    * @default 'application/json'.
    * The default content type if the 'Content-Type' request header is missing.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloaddefaultcontenttype)
    */
  var defaultContentType: js.UndefOr[String] = js.native
  /**
    * @default 'error' (return a Bad Request (400) error response).
    * A failAction value which determines how to handle payload parsing errors.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadfailaction)
    */
  var failAction: js.UndefOr[FailAction] = js.native
  /**
    * @default 1048576 (1MB).
    * Limits the size of incoming payloads to the specified byte count. Allowing very large payloads may cause the server to run out of memory.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadmaxbytes)
    */
  var maxBytes: js.UndefOr[Double] = js.native
  /**
    * @default none.
    * Overrides payload processing for multipart requests. Value can be one of:
    * * false - disable multipart processing.
    * an object with the following required options:
    * * output - same as the output option with an additional value option:
    * * * annotated - wraps each multipart part in an object with the following keys: // TODO type this?
    * * * * headers - the part headers.
    * * * * filename - the part file name.
    * * * * payload - the processed part payload.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadmultipart)
    */
  var multipart: js.UndefOr[`false` | AnonOutput] = js.native
  /**
    * @default 'data'.
    * The processed payload format. The value must be one of:
    * * 'data' - the incoming payload is read fully into memory. If parse is true, the payload is parsed (JSON, form-decoded, multipart) based on the 'Content-Type' header. If parse is false, a raw
    * Buffer is returned.
    * * 'stream' - the incoming payload is made available via a Stream.Readable interface. If the payload is 'multipart/form-data' and parse is true, field values are presented as text while files
    * are provided as streams. File streams from a 'multipart/form-data' upload will also have a hapi property containing the filename and headers properties. Note that payload streams for multipart
    * payloads are a synthetic interface created on top of the entire mutlipart content loaded into memory. To avoid loading large multipart payloads into memory, set parse to false and handle the
    * multipart payload in the handler using a streaming parser (e.g. pez).
    * * 'file' - the incoming payload is written to temporary file in the directory specified by the uploads settings. If the payload is 'multipart/form-data' and parse is true, field values are
    * presented as text while files are saved to disk. Note that it is the sole responsibility of the application to clean up the files generated by the framework. This can be done by keeping track
    * of which files are used (e.g. using the request.app object), and listening to the server 'response' event to perform cleanup.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadoutput)
    */
  var output: js.UndefOr[PayloadOutput] = js.native
  /**
    * @default none.
    * A mime type string overriding the 'Content-Type' header value received.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadoverride)
    */
  var `override`: js.UndefOr[String] = js.native
  /**
    * @default true.
    * Determines if the incoming payload is processed or presented raw. Available values:
    * * true - if the request 'Content-Type' matches the allowed mime types set by allow (for the whole payload as well as parts), the payload is converted into an object when possible. If the
    * format is unknown, a Bad Request (400) error response is sent. Any known content encoding is decoded.
    * * false - the raw payload is returned unmodified.
    * * 'gunzip' - the raw payload is returned unmodified after any known content encoding is decoded.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadparse)
    */
  var parse: js.UndefOr[Boolean | gunzip] = js.native
  /**
    * @default to 10000 (10 seconds).
    * Payload reception timeout in milliseconds. Sets the maximum time allowed for the client to transmit the request payload (body) before giving up and responding with a Request Timeout (408)
    * error response. Set to false to disable.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadtimeout)
    */
  var timeout: js.UndefOr[`false` | Double] = js.native
  /**
    * @default os.tmpdir().
    * The directory used for writing file uploads.
    * [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloaduploads)
    */
  var uploads: js.UndefOr[String] = js.native
}

object RouteOptionsPayload {
  @scala.inline
  def apply(): RouteOptionsPayload = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[RouteOptionsPayload]
  }
  @scala.inline
  implicit class RouteOptionsPayloadOps[Self <: RouteOptionsPayload] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withAllow(value: String | js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("allow")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAllow: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("allow")(js.undefined)
        ret
    }
    @scala.inline
    def withCompression(value: Dictionary[PayloadCompressionDecoderSettings]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("compression")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCompression: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("compression")(js.undefined)
        ret
    }
    @scala.inline
    def withDefaultContentType(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("defaultContentType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDefaultContentType: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("defaultContentType")(js.undefined)
        ret
    }
    @scala.inline
    def withFailActionFunction3(
      value: (/* request */ Request, /* h */ ResponseToolkit, /* err */ js.UndefOr[js.Error]) => ReturnValue
    ): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("failAction")(js.Any.fromFunction3(value))
        ret
    }
    @scala.inline
    def withFailAction(value: FailAction): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("failAction")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutFailAction: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("failAction")(js.undefined)
        ret
    }
    @scala.inline
    def withMaxBytes(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("maxBytes")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutMaxBytes: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("maxBytes")(js.undefined)
        ret
    }
    @scala.inline
    def withMultipart(value: `false` | AnonOutput): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("multipart")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutMultipart: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("multipart")(js.undefined)
        ret
    }
    @scala.inline
    def withOutput(value: PayloadOutput): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("output")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutOutput: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("output")(js.undefined)
        ret
    }
    @scala.inline
    def withOverride(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("override")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutOverride: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("override")(js.undefined)
        ret
    }
    @scala.inline
    def withParse(value: Boolean | gunzip): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("parse")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutParse: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("parse")(js.undefined)
        ret
    }
    @scala.inline
    def withTimeout(value: `false` | Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timeout")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTimeout: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timeout")(js.undefined)
        ret
    }
    @scala.inline
    def withUploads(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("uploads")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutUploads: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("uploads")(js.undefined)
        ret
    }
  }
  
}

