package typingsSlinky.intlTelInput.mod

import org.scalajs.dom.raw.Node
import typingsSlinky.intlTelInput.intlTelInputStrings.aggressive
import typingsSlinky.intlTelInput.intlTelInputStrings.off
import typingsSlinky.intlTelInput.intlTelInputStrings.polite
import typingsSlinky.intlTelInput.mod.intlTelInputUtils.CountryData
import typingsSlinky.intlTelInput.mod.intlTelInputUtils.placeholderNumberType
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait Options extends js.Object {
  /**
    * Whether or not to allow the dropdown. If disabled, there is no dropdown
    * arrow, and the selected flag is not clickable. Also we display the
    * selected flag on the right instead because it is just a marker of state.
    * Default = true
    */
  var allowDropdown: js.UndefOr[Boolean] = js.native
  /**
    * If there is just a dial code in the input: remove it on blur or submit,
    * and re-add it on focus. This is to prevent just a dial code getting
    * submitted with the form. Requires nationalMode to be set to false.
    * Default = true
    */
  var autoHideDialCode: js.UndefOr[Boolean] = js.native
  /**
    * Set the input's placeholder to an example number for the selected country, and update it if the country changes.
    * You can specify the number type using the placeholderNumberType option.
    * By default it is set to "polite", which means it will only set the placeholder if the input doesn't already have one.
    * You can also set it to "aggressive", which will replace any existing placeholder, or "off".
    * Requires the utilsScript option.
    * Default = "polite"
    */
  var autoPlaceholder: js.UndefOr[off | polite | aggressive] = js.native
  /**
    * Change the placeholder generated by autoPlaceholder. Must return a string.
    * Default = null
    */
  var customPlaceholder: js.UndefOr[
    js.Function2[
      /* selectedCountryPlaceholder */ String, 
      /* selectedCountryData */ CountryData, 
      String
    ]
  ] = js.native
  /**
    * Expects a node e.g. document.body. Instead of putting the country dropdown next to the input,
    * append it to the specified node, and it will then be positioned absolutely next to the input using JavaScript.
    * This is useful when the input is inside a container with overflow: hidden.
    * Note that the absolute positioning can be broken by scrolling, so it will automatically close on the window scroll event.
    * Default = null
    */
  var dropdownContainer: js.UndefOr[Node] = js.native
  /**
    * In the dropdown, display all countries except the ones you specify here.
    * Default = null
    */
  var excludeCountries: js.UndefOr[js.Array[String]] = js.native
  /**
    * Format the input value (according to the nationalMode option) during initialisation, and on setNumber.
    * Requires the utilsScript option.
    * Default = true
    */
  var formatOnDisplay: js.UndefOr[Boolean] = js.native
  /**
    * When setting initialCountry to "auto", you must use this option to
    * specify a custom function that looks up the user's location,
    * and then calls the success callback with the relevant country code.
    * Also note that when instantiating the plugin, if the Promise object is defined,
    * one of those is returned under the promise instance property, so you can
    * do something like iti.promise.then(callback) to know when initialisation requests like this have completed.
    * Default = null
    */
  var geoIpLookup: js.UndefOr[js.Function1[/* callback */ js.Function1[/* countryCode */ String, Unit], Unit]] = js.native
  /**
    * Add a hidden input with the given name (or if your input name contains square brackets then it will give the hidden input the same name,
    * replacing the contents of the brackets with the given name). On submit, populate it with the full international number (using getNumber).
    * This is a quick way for people using non-ajax forms to get the full international number, even when nationalMode is enabled.
    * Note: requires the input to be inside a form element, as this feature works by listening for the submit event on the closest form element.
    * Also note that since this uses getNumber internally, it expects a valid number, and so should only be used after validation.
    * Default = ""
    */
  var hiddenInput: js.UndefOr[String] = js.native
  /**
    * Set the initial country selection by specifying it's country code.
    * You can also set it to "auto", which will lookup the user's country based
    * on their IP address (requires the geoIpLookup option).
    * Note that the "auto" option will not update the country selection if the
    * input already contains a number. If you leave initialCountry blank,
    * it will default to the first country in the list.
    */
  var initialCountry: js.UndefOr[String] = js.native
  /**
    * Allows to translate the countries by its given iso code e.g.: { 'de': 'Deutschland' }
    * Default = {}
    */
  var localizedCountries: js.UndefOr[js.Object] = js.native
  /**
    * Allow users to enter national numbers (and not have to think about
    * international dial codes). Formatting, validation and placeholders still
    * work. Then you can use getNumber to extract a full international number.
    * This option now defaults to true, and it is recommended that you leave it
    * that way as it provides a better experience for the user.
    * Default = true
    */
  var nationalMode: js.UndefOr[Boolean] = js.native
  /**
    * In the dropdown, display only the countries you specify.
    * Default = undefined
    */
  var onlyCountries: js.UndefOr[js.Array[String]] = js.native
  /**
    * Specify one of the keys from the global enum intlTelInputUtils.numberType
    * e.g. "FIXED_LINE" to set the number type to use for the placeholder.
    * Default = MOBILE
    */
  var placeholderNumberType: js.UndefOr[typingsSlinky.intlTelInput.mod.intlTelInputUtils.placeholderNumberType] = js.native
  /**
    * Specify the countries to appear at the top of the list.
    * Default = ["us", "gb"]
    */
  var preferredCountries: js.UndefOr[js.Array[String]] = js.native
  /**
    * Display the country dial code next to the selected flag so it's not part
    * of the typed number. Note that this will disable nationalMode because
    * technically we are dealing with international numbers, but with the
    * dial code separated.
    * Default = false
    */
  var separateDialCode: js.UndefOr[Boolean] = js.native
  /**
    * Enable formatting/validation etc. by specifying the URL of the included utils.js script
    * (or alternatively just point it to the file on cdnjs.com). The script is fetched when the page has finished loading (on the window load event)
    *  to prevent blocking (the script is ~215KB). When instantiating the plugin, if the Promise object is defined,
    * one of those is returned under the promise instance property, so you can do something like
    * iti.promise.then(callback) to know when initialisation requests like this have finished.
    * Note that if you're lazy loading the plugin script itself (intlTelInput.js)
    * this will not work and you will need to use the loadUtils method instead.
    * Example: "build/js/utils.js"
    * Default = ""
    */
  var utilsScript: js.UndefOr[String] = js.native
}

object Options {
  @scala.inline
  def apply(): Options = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[Options]
  }
  @scala.inline
  implicit class OptionsOps[Self <: Options] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withAllowDropdown(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("allowDropdown")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAllowDropdown: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("allowDropdown")(js.undefined)
        ret
    }
    @scala.inline
    def withAutoHideDialCode(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("autoHideDialCode")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAutoHideDialCode: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("autoHideDialCode")(js.undefined)
        ret
    }
    @scala.inline
    def withAutoPlaceholder(value: off | polite | aggressive): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("autoPlaceholder")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAutoPlaceholder: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("autoPlaceholder")(js.undefined)
        ret
    }
    @scala.inline
    def withCustomPlaceholder(value: (/* selectedCountryPlaceholder */ String, /* selectedCountryData */ CountryData) => String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("customPlaceholder")(js.Any.fromFunction2(value))
        ret
    }
    @scala.inline
    def withoutCustomPlaceholder: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("customPlaceholder")(js.undefined)
        ret
    }
    @scala.inline
    def withDropdownContainer(value: Node): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dropdownContainer")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDropdownContainer: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("dropdownContainer")(js.undefined)
        ret
    }
    @scala.inline
    def withExcludeCountries(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("excludeCountries")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutExcludeCountries: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("excludeCountries")(js.undefined)
        ret
    }
    @scala.inline
    def withFormatOnDisplay(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("formatOnDisplay")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutFormatOnDisplay: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("formatOnDisplay")(js.undefined)
        ret
    }
    @scala.inline
    def withGeoIpLookup(value: /* callback */ js.Function1[/* countryCode */ String, Unit] => Unit): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("geoIpLookup")(js.Any.fromFunction1(value))
        ret
    }
    @scala.inline
    def withoutGeoIpLookup: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("geoIpLookup")(js.undefined)
        ret
    }
    @scala.inline
    def withHiddenInput(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hiddenInput")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutHiddenInput: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("hiddenInput")(js.undefined)
        ret
    }
    @scala.inline
    def withInitialCountry(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("initialCountry")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutInitialCountry: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("initialCountry")(js.undefined)
        ret
    }
    @scala.inline
    def withLocalizedCountries(value: js.Object): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("localizedCountries")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLocalizedCountries: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("localizedCountries")(js.undefined)
        ret
    }
    @scala.inline
    def withNationalMode(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("nationalMode")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutNationalMode: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("nationalMode")(js.undefined)
        ret
    }
    @scala.inline
    def withOnlyCountries(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("onlyCountries")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutOnlyCountries: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("onlyCountries")(js.undefined)
        ret
    }
    @scala.inline
    def withPlaceholderNumberType(value: placeholderNumberType): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("placeholderNumberType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPlaceholderNumberType: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("placeholderNumberType")(js.undefined)
        ret
    }
    @scala.inline
    def withPreferredCountries(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("preferredCountries")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPreferredCountries: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("preferredCountries")(js.undefined)
        ret
    }
    @scala.inline
    def withSeparateDialCode(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("separateDialCode")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSeparateDialCode: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("separateDialCode")(js.undefined)
        ret
    }
    @scala.inline
    def withUtilsScript(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("utilsScript")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutUtilsScript: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("utilsScript")(js.undefined)
        ret
    }
  }
  
}

