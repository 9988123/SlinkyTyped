package typingsSlinky.awsSdk.transferMod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait CreateServerRequest extends js.Object {
  /**
    * The virtual private cloud (VPC) endpoint settings that are configured for your SFTP server. With a VPC endpoint, you can restrict access to your SFTP server to resources only within your VPC. To control incoming internet traffic, you will need to invoke the UpdateServer API and attach an Elastic IP to your server's endpoint. 
    */
  var EndpointDetails: js.UndefOr[typingsSlinky.awsSdk.transferMod.EndpointDetails] = js.native
  /**
    * The type of VPC endpoint that you want your SFTP server to connect to. You can choose to connect to the public internet or a virtual private cloud (VPC) endpoint. With a VPC endpoint, you can restrict access to your SFTP server and resources only within your VPC.
    */
  var EndpointType: js.UndefOr[typingsSlinky.awsSdk.transferMod.EndpointType] = js.native
  /**
    * The RSA private key as generated by the ssh-keygen -N "" -f my-new-server-key command.  If you aren't planning to migrate existing users from an existing SFTP server to a new AWS SFTP server, don't update the host key. Accidentally changing a server's host key can be disruptive.   For more information, see "https://alpha-docs-aws.amazon.com/transfer/latest/userguide/configuring-servers.html#change-host-key" in the AWS SFTP User Guide. 
    */
  var HostKey: js.UndefOr[typingsSlinky.awsSdk.transferMod.HostKey] = js.native
  /**
    * This parameter is required when the IdentityProviderType is set to API_GATEWAY. Accepts an array containing all of the information required to call a customer-supplied authentication API, including the API Gateway URL. This property is not required when the IdentityProviderType is set to SERVICE_MANAGED.
    */
  var IdentityProviderDetails: js.UndefOr[typingsSlinky.awsSdk.transferMod.IdentityProviderDetails] = js.native
  /**
    * Specifies the mode of authentication for the SFTP server. The default value is SERVICE_MANAGED, which allows you to store and access SFTP user credentials within the AWS Transfer for SFTP service. Use the API_GATEWAY value to integrate with an identity provider of your choosing. The API_GATEWAY setting requires you to provide an API Gateway endpoint URL to call for authentication using the IdentityProviderDetails parameter.
    */
  var IdentityProviderType: js.UndefOr[typingsSlinky.awsSdk.transferMod.IdentityProviderType] = js.native
  /**
    * A value that allows the service to write your SFTP users' activity to your Amazon CloudWatch logs for monitoring and auditing purposes.
    */
  var LoggingRole: js.UndefOr[Role] = js.native
  /**
    * Key-value pairs that can be used to group and search for servers.
    */
  var Tags: js.UndefOr[typingsSlinky.awsSdk.transferMod.Tags] = js.native
}

object CreateServerRequest {
  @scala.inline
  def apply(): CreateServerRequest = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[CreateServerRequest]
  }
  @scala.inline
  implicit class CreateServerRequestOps[Self <: CreateServerRequest] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withEndpointDetails(value: EndpointDetails): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("EndpointDetails")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEndpointDetails: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("EndpointDetails")(js.undefined)
        ret
    }
    @scala.inline
    def withEndpointType(value: EndpointType): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("EndpointType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEndpointType: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("EndpointType")(js.undefined)
        ret
    }
    @scala.inline
    def withHostKey(value: HostKey): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("HostKey")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutHostKey: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("HostKey")(js.undefined)
        ret
    }
    @scala.inline
    def withIdentityProviderDetails(value: IdentityProviderDetails): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("IdentityProviderDetails")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutIdentityProviderDetails: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("IdentityProviderDetails")(js.undefined)
        ret
    }
    @scala.inline
    def withIdentityProviderType(value: IdentityProviderType): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("IdentityProviderType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutIdentityProviderType: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("IdentityProviderType")(js.undefined)
        ret
    }
    @scala.inline
    def withLoggingRole(value: Role): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("LoggingRole")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLoggingRole: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("LoggingRole")(js.undefined)
        ret
    }
    @scala.inline
    def withTags(value: Tags): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Tags")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTags: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Tags")(js.undefined)
        ret
    }
  }
  
}

