package typingsSlinky.jestTypes.configMod

import org.scalablytyped.runtime.StringDictionary
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/* Inlined yargs.yargs.Arguments<std.Partial<{  all  :boolean,   automock  :boolean,   bail  :boolean | number,   browser  :boolean,   cache  :boolean,   cacheDirectory  :string,   changedFilesWithAncestor  :boolean,   changedSince  :string,   ci  :boolean,   clearCache  :boolean,   clearMocks  :boolean,   collectCoverage  :boolean,   collectCoverageFrom  :string,   collectCoverageOnlyFrom  :std.Array<string>,   color  :boolean,   colors  :boolean,   config  :string,   coverage  :boolean,   coverageDirectory  :string,   coveragePathIgnorePatterns  :std.Array<string>,   coverageReporters  :std.Array<string>,   coverageThreshold  :string,   debug  :boolean,   env  :string,   expand  :boolean,   findRelatedTests  :boolean,   forceExit  :boolean,   globals  :string,   globalSetup  :string | null | undefined,   globalTeardown  :string | null | undefined,   haste  :string,   init  :boolean,   json  :boolean,   lastCommit  :boolean,   logHeapUsage  :boolean,   maxWorkers  :number | string,   moduleDirectories  :std.Array<string>,   moduleFileExtensions  :std.Array<string>,   moduleNameMapper  :string,   modulePathIgnorePatterns  :std.Array<string>,   modulePaths  :std.Array<string>,   noStackTrace  :boolean,   notify  :boolean,   notifyMode  :string,   onlyChanged  :boolean,   outputFile  :string,   preset  :string | null | undefined,   projects  :std.Array<string>,   prettierPath  :string | null | undefined,   resetMocks  :boolean,   resetModules  :boolean,   resolver  :string | null | undefined,   restoreMocks  :boolean,   rootDir  :string,   roots  :std.Array<string>,   runInBand  :boolean,   setupFiles  :std.Array<string>,   setupFilesAfterEnv  :std.Array<string>,   showConfig  :boolean,   silent  :boolean,   snapshotSerializers  :std.Array<string>,   testEnvironment  :string,   testFailureExitCode  :string | null | undefined,   testMatch  :std.Array<string>,   testNamePattern  :string,   testPathIgnorePatterns  :std.Array<string>,   testPathPattern  :std.Array<string>,   testRegex  :string | std.Array<string>,   testResultsProcessor  :string | null | undefined,   testRunner  :string,   testSequencer  :string,   testURL  :string,   testTimeout  :number | null | undefined,   timers  :string,   transform  :string,   transformIgnorePatterns  :std.Array<string>,   unmockedModulePathPatterns  :std.Array<string> | null | undefined,   updateSnapshot  :boolean,   useStderr  :boolean,   verbose  :boolean | null | undefined,   version  :boolean,   watch  :boolean,   watchAll  :boolean,   watchman  :boolean,   watchPathIgnorePatterns  :std.Array<string>}>> */
@js.native
trait Argv
  extends /** All remaining options */
/* argName */ StringDictionary[js.Any] {
  /** The script name or node command */
  @JSName("$0")
  var $0: String = js.native
  /** Non-option arguments */
  @JSName("_")
  var _underscore: js.Array[String] = js.native
  var all: js.UndefOr[Boolean] = js.native
  var automock: js.UndefOr[Boolean] = js.native
  var bail: js.UndefOr[Boolean | Double] = js.native
  var browser: js.UndefOr[Boolean] = js.native
  var cache: js.UndefOr[Boolean] = js.native
  var cacheDirectory: js.UndefOr[String] = js.native
  var changedFilesWithAncestor: js.UndefOr[Boolean] = js.native
  var changedSince: js.UndefOr[String] = js.native
  var ci: js.UndefOr[Boolean] = js.native
  var clearCache: js.UndefOr[Boolean] = js.native
  var clearMocks: js.UndefOr[Boolean] = js.native
  var collectCoverage: js.UndefOr[Boolean] = js.native
  var collectCoverageFrom: js.UndefOr[String] = js.native
  var collectCoverageOnlyFrom: js.UndefOr[js.Array[String]] = js.native
  var color: js.UndefOr[Boolean] = js.native
  var colors: js.UndefOr[Boolean] = js.native
  var config: js.UndefOr[String] = js.native
  var coverage: js.UndefOr[Boolean] = js.native
  var coverageDirectory: js.UndefOr[String] = js.native
  var coveragePathIgnorePatterns: js.UndefOr[js.Array[String]] = js.native
  var coverageReporters: js.UndefOr[js.Array[String]] = js.native
  var coverageThreshold: js.UndefOr[String] = js.native
  var debug: js.UndefOr[Boolean] = js.native
  var env: js.UndefOr[String] = js.native
  var expand: js.UndefOr[Boolean] = js.native
  var findRelatedTests: js.UndefOr[Boolean] = js.native
  var forceExit: js.UndefOr[Boolean] = js.native
  var globalSetup: js.UndefOr[String] = js.native
  var globalTeardown: js.UndefOr[String] = js.native
  var globals: js.UndefOr[String] = js.native
  var haste: js.UndefOr[String] = js.native
  var init: js.UndefOr[Boolean] = js.native
  var json: js.UndefOr[Boolean] = js.native
  var lastCommit: js.UndefOr[Boolean] = js.native
  var logHeapUsage: js.UndefOr[Boolean] = js.native
  var maxWorkers: js.UndefOr[Double | String] = js.native
  var moduleDirectories: js.UndefOr[js.Array[String]] = js.native
  var moduleFileExtensions: js.UndefOr[js.Array[String]] = js.native
  var moduleNameMapper: js.UndefOr[String] = js.native
  var modulePathIgnorePatterns: js.UndefOr[js.Array[String]] = js.native
  var modulePaths: js.UndefOr[js.Array[String]] = js.native
  var noStackTrace: js.UndefOr[Boolean] = js.native
  var notifyMode: js.UndefOr[String] = js.native
  @JSName("notify")
  var notify_FArgv: js.UndefOr[Boolean] = js.native
  var onlyChanged: js.UndefOr[Boolean] = js.native
  var outputFile: js.UndefOr[String] = js.native
  var preset: js.UndefOr[String] = js.native
  var prettierPath: js.UndefOr[String] = js.native
  var projects: js.UndefOr[js.Array[String]] = js.native
  var resetMocks: js.UndefOr[Boolean] = js.native
  var resetModules: js.UndefOr[Boolean] = js.native
  var resolver: js.UndefOr[String] = js.native
  var restoreMocks: js.UndefOr[Boolean] = js.native
  var rootDir: js.UndefOr[String] = js.native
  var roots: js.UndefOr[js.Array[String]] = js.native
  var runInBand: js.UndefOr[Boolean] = js.native
  var setupFiles: js.UndefOr[js.Array[String]] = js.native
  var setupFilesAfterEnv: js.UndefOr[js.Array[String]] = js.native
  var showConfig: js.UndefOr[Boolean] = js.native
  var silent: js.UndefOr[Boolean] = js.native
  var snapshotSerializers: js.UndefOr[js.Array[String]] = js.native
  var testEnvironment: js.UndefOr[String] = js.native
  var testFailureExitCode: js.UndefOr[String] = js.native
  var testMatch: js.UndefOr[js.Array[String]] = js.native
  var testNamePattern: js.UndefOr[String] = js.native
  var testPathIgnorePatterns: js.UndefOr[js.Array[String]] = js.native
  var testPathPattern: js.UndefOr[js.Array[String]] = js.native
  var testRegex: js.UndefOr[String | js.Array[String]] = js.native
  var testResultsProcessor: js.UndefOr[String] = js.native
  var testRunner: js.UndefOr[String] = js.native
  var testSequencer: js.UndefOr[String] = js.native
  var testTimeout: js.UndefOr[Double] = js.native
  var testURL: js.UndefOr[String] = js.native
  var timers: js.UndefOr[String] = js.native
  var transform: js.UndefOr[String] = js.native
  var transformIgnorePatterns: js.UndefOr[js.Array[String]] = js.native
  var unmockedModulePathPatterns: js.UndefOr[js.Array[String]] = js.native
  var updateSnapshot: js.UndefOr[Boolean] = js.native
  var useStderr: js.UndefOr[Boolean] = js.native
  var verbose: js.UndefOr[Boolean] = js.native
  var version: js.UndefOr[Boolean] = js.native
  var watch: js.UndefOr[Boolean] = js.native
  var watchAll: js.UndefOr[Boolean] = js.native
  var watchPathIgnorePatterns: js.UndefOr[js.Array[String]] = js.native
  var watchman: js.UndefOr[Boolean] = js.native
}

object Argv {
  @scala.inline
  def apply($0: String, _underscore: js.Array[String]): Argv = {
    val __obj = js.Dynamic.literal($0 = $0.asInstanceOf[js.Any])
    __obj.updateDynamic("_")(_underscore.asInstanceOf[js.Any])
    __obj.asInstanceOf[Argv]
  }
  @scala.inline
  implicit class ArgvOps[Self <: Argv] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def with$0(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("$0")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def with_underscore(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("_")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withAll(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("all")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAll: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("all")(js.undefined)
        ret
    }
    @scala.inline
    def withAutomock(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("automock")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutAutomock: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("automock")(js.undefined)
        ret
    }
    @scala.inline
    def withBail(value: Boolean | Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("bail")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutBail: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("bail")(js.undefined)
        ret
    }
    @scala.inline
    def withBrowser(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("browser")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutBrowser: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("browser")(js.undefined)
        ret
    }
    @scala.inline
    def withCache(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cache")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCache: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cache")(js.undefined)
        ret
    }
    @scala.inline
    def withCacheDirectory(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cacheDirectory")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCacheDirectory: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("cacheDirectory")(js.undefined)
        ret
    }
    @scala.inline
    def withChangedFilesWithAncestor(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("changedFilesWithAncestor")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutChangedFilesWithAncestor: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("changedFilesWithAncestor")(js.undefined)
        ret
    }
    @scala.inline
    def withChangedSince(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("changedSince")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutChangedSince: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("changedSince")(js.undefined)
        ret
    }
    @scala.inline
    def withCi(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ci")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCi: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ci")(js.undefined)
        ret
    }
    @scala.inline
    def withClearCache(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("clearCache")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutClearCache: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("clearCache")(js.undefined)
        ret
    }
    @scala.inline
    def withClearMocks(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("clearMocks")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutClearMocks: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("clearMocks")(js.undefined)
        ret
    }
    @scala.inline
    def withCollectCoverage(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("collectCoverage")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCollectCoverage: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("collectCoverage")(js.undefined)
        ret
    }
    @scala.inline
    def withCollectCoverageFrom(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("collectCoverageFrom")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCollectCoverageFrom: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("collectCoverageFrom")(js.undefined)
        ret
    }
    @scala.inline
    def withCollectCoverageOnlyFrom(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("collectCoverageOnlyFrom")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCollectCoverageOnlyFrom: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("collectCoverageOnlyFrom")(js.undefined)
        ret
    }
    @scala.inline
    def withColor(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("color")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutColor: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("color")(js.undefined)
        ret
    }
    @scala.inline
    def withColors(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("colors")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutColors: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("colors")(js.undefined)
        ret
    }
    @scala.inline
    def withConfig(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("config")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutConfig: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("config")(js.undefined)
        ret
    }
    @scala.inline
    def withCoverage(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coverage")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCoverage: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coverage")(js.undefined)
        ret
    }
    @scala.inline
    def withCoverageDirectory(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coverageDirectory")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCoverageDirectory: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coverageDirectory")(js.undefined)
        ret
    }
    @scala.inline
    def withCoveragePathIgnorePatterns(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coveragePathIgnorePatterns")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCoveragePathIgnorePatterns: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coveragePathIgnorePatterns")(js.undefined)
        ret
    }
    @scala.inline
    def withCoverageReporters(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coverageReporters")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCoverageReporters: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coverageReporters")(js.undefined)
        ret
    }
    @scala.inline
    def withCoverageThreshold(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coverageThreshold")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutCoverageThreshold: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("coverageThreshold")(js.undefined)
        ret
    }
    @scala.inline
    def withDebug(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("debug")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutDebug: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("debug")(js.undefined)
        ret
    }
    @scala.inline
    def withEnv(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("env")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutEnv: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("env")(js.undefined)
        ret
    }
    @scala.inline
    def withExpand(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("expand")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutExpand: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("expand")(js.undefined)
        ret
    }
    @scala.inline
    def withFindRelatedTests(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("findRelatedTests")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutFindRelatedTests: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("findRelatedTests")(js.undefined)
        ret
    }
    @scala.inline
    def withForceExit(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("forceExit")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutForceExit: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("forceExit")(js.undefined)
        ret
    }
    @scala.inline
    def withGlobalSetup(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globalSetup")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGlobalSetup: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globalSetup")(js.undefined)
        ret
    }
    @scala.inline
    def withGlobalTeardown(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globalTeardown")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGlobalTeardown: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globalTeardown")(js.undefined)
        ret
    }
    @scala.inline
    def withGlobals(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globals")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutGlobals: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("globals")(js.undefined)
        ret
    }
    @scala.inline
    def withHaste(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("haste")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutHaste: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("haste")(js.undefined)
        ret
    }
    @scala.inline
    def withInit(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("init")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutInit: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("init")(js.undefined)
        ret
    }
    @scala.inline
    def withJson(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("json")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutJson: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("json")(js.undefined)
        ret
    }
    @scala.inline
    def withLastCommit(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("lastCommit")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLastCommit: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("lastCommit")(js.undefined)
        ret
    }
    @scala.inline
    def withLogHeapUsage(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("logHeapUsage")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutLogHeapUsage: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("logHeapUsage")(js.undefined)
        ret
    }
    @scala.inline
    def withMaxWorkers(value: Double | String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("maxWorkers")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutMaxWorkers: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("maxWorkers")(js.undefined)
        ret
    }
    @scala.inline
    def withModuleDirectories(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moduleDirectories")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutModuleDirectories: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moduleDirectories")(js.undefined)
        ret
    }
    @scala.inline
    def withModuleFileExtensions(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moduleFileExtensions")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutModuleFileExtensions: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moduleFileExtensions")(js.undefined)
        ret
    }
    @scala.inline
    def withModuleNameMapper(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moduleNameMapper")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutModuleNameMapper: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("moduleNameMapper")(js.undefined)
        ret
    }
    @scala.inline
    def withModulePathIgnorePatterns(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("modulePathIgnorePatterns")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutModulePathIgnorePatterns: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("modulePathIgnorePatterns")(js.undefined)
        ret
    }
    @scala.inline
    def withModulePaths(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("modulePaths")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutModulePaths: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("modulePaths")(js.undefined)
        ret
    }
    @scala.inline
    def withNoStackTrace(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("noStackTrace")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutNoStackTrace: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("noStackTrace")(js.undefined)
        ret
    }
    @scala.inline
    def withNotify(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("notify")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutNotify: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("notify")(js.undefined)
        ret
    }
    @scala.inline
    def withNotifyMode(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("notifyMode")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutNotifyMode: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("notifyMode")(js.undefined)
        ret
    }
    @scala.inline
    def withOnlyChanged(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("onlyChanged")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutOnlyChanged: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("onlyChanged")(js.undefined)
        ret
    }
    @scala.inline
    def withOutputFile(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("outputFile")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutOutputFile: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("outputFile")(js.undefined)
        ret
    }
    @scala.inline
    def withPreset(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("preset")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPreset: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("preset")(js.undefined)
        ret
    }
    @scala.inline
    def withPrettierPath(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("prettierPath")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutPrettierPath: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("prettierPath")(js.undefined)
        ret
    }
    @scala.inline
    def withProjects(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("projects")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutProjects: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("projects")(js.undefined)
        ret
    }
    @scala.inline
    def withResetMocks(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("resetMocks")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutResetMocks: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("resetMocks")(js.undefined)
        ret
    }
    @scala.inline
    def withResetModules(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("resetModules")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutResetModules: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("resetModules")(js.undefined)
        ret
    }
    @scala.inline
    def withResolver(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("resolver")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutResolver: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("resolver")(js.undefined)
        ret
    }
    @scala.inline
    def withRestoreMocks(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("restoreMocks")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRestoreMocks: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("restoreMocks")(js.undefined)
        ret
    }
    @scala.inline
    def withRootDir(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("rootDir")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRootDir: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("rootDir")(js.undefined)
        ret
    }
    @scala.inline
    def withRoots(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("roots")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRoots: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("roots")(js.undefined)
        ret
    }
    @scala.inline
    def withRunInBand(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("runInBand")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutRunInBand: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("runInBand")(js.undefined)
        ret
    }
    @scala.inline
    def withSetupFiles(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setupFiles")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSetupFiles: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setupFiles")(js.undefined)
        ret
    }
    @scala.inline
    def withSetupFilesAfterEnv(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setupFilesAfterEnv")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSetupFilesAfterEnv: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("setupFilesAfterEnv")(js.undefined)
        ret
    }
    @scala.inline
    def withShowConfig(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("showConfig")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutShowConfig: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("showConfig")(js.undefined)
        ret
    }
    @scala.inline
    def withSilent(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("silent")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSilent: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("silent")(js.undefined)
        ret
    }
    @scala.inline
    def withSnapshotSerializers(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("snapshotSerializers")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutSnapshotSerializers: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("snapshotSerializers")(js.undefined)
        ret
    }
    @scala.inline
    def withTestEnvironment(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testEnvironment")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestEnvironment: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testEnvironment")(js.undefined)
        ret
    }
    @scala.inline
    def withTestFailureExitCode(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testFailureExitCode")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestFailureExitCode: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testFailureExitCode")(js.undefined)
        ret
    }
    @scala.inline
    def withTestMatch(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testMatch")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestMatch: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testMatch")(js.undefined)
        ret
    }
    @scala.inline
    def withTestNamePattern(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testNamePattern")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestNamePattern: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testNamePattern")(js.undefined)
        ret
    }
    @scala.inline
    def withTestPathIgnorePatterns(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testPathIgnorePatterns")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestPathIgnorePatterns: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testPathIgnorePatterns")(js.undefined)
        ret
    }
    @scala.inline
    def withTestPathPattern(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testPathPattern")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestPathPattern: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testPathPattern")(js.undefined)
        ret
    }
    @scala.inline
    def withTestRegex(value: String | js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testRegex")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestRegex: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testRegex")(js.undefined)
        ret
    }
    @scala.inline
    def withTestResultsProcessor(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testResultsProcessor")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestResultsProcessor: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testResultsProcessor")(js.undefined)
        ret
    }
    @scala.inline
    def withTestRunner(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testRunner")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestRunner: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testRunner")(js.undefined)
        ret
    }
    @scala.inline
    def withTestSequencer(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testSequencer")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestSequencer: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testSequencer")(js.undefined)
        ret
    }
    @scala.inline
    def withTestTimeout(value: Double): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testTimeout")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestTimeout: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testTimeout")(js.undefined)
        ret
    }
    @scala.inline
    def withTestURL(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testURL")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTestURL: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("testURL")(js.undefined)
        ret
    }
    @scala.inline
    def withTimers(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timers")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTimers: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("timers")(js.undefined)
        ret
    }
    @scala.inline
    def withTransform(value: String): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("transform")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTransform: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("transform")(js.undefined)
        ret
    }
    @scala.inline
    def withTransformIgnorePatterns(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("transformIgnorePatterns")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutTransformIgnorePatterns: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("transformIgnorePatterns")(js.undefined)
        ret
    }
    @scala.inline
    def withUnmockedModulePathPatterns(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("unmockedModulePathPatterns")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutUnmockedModulePathPatterns: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("unmockedModulePathPatterns")(js.undefined)
        ret
    }
    @scala.inline
    def withUpdateSnapshot(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("updateSnapshot")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutUpdateSnapshot: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("updateSnapshot")(js.undefined)
        ret
    }
    @scala.inline
    def withUseStderr(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("useStderr")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutUseStderr: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("useStderr")(js.undefined)
        ret
    }
    @scala.inline
    def withVerbose(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("verbose")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutVerbose: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("verbose")(js.undefined)
        ret
    }
    @scala.inline
    def withVersion(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("version")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutVersion: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("version")(js.undefined)
        ret
    }
    @scala.inline
    def withWatch(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watch")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutWatch: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watch")(js.undefined)
        ret
    }
    @scala.inline
    def withWatchAll(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watchAll")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutWatchAll: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watchAll")(js.undefined)
        ret
    }
    @scala.inline
    def withWatchPathIgnorePatterns(value: js.Array[String]): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watchPathIgnorePatterns")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutWatchPathIgnorePatterns: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watchPathIgnorePatterns")(js.undefined)
        ret
    }
    @scala.inline
    def withWatchman(value: Boolean): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watchman")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withoutWatchman: Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("watchman")(js.undefined)
        ret
    }
  }
  
}

