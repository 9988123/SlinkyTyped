package typingsSlinky.babelTypes.mod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/* Rewritten from type alias, can be one of: 
  - typingsSlinky.babelTypes.mod.ArrayExpression_
  - typingsSlinky.babelTypes.mod.AssignmentExpression_
  - typingsSlinky.babelTypes.mod.BinaryExpression_
  - typingsSlinky.babelTypes.mod.CallExpression_
  - typingsSlinky.babelTypes.mod.ConditionalExpression_
  - typingsSlinky.babelTypes.mod.FunctionExpression_
  - typingsSlinky.babelTypes.mod.Identifier_
  - typingsSlinky.babelTypes.mod.StringLiteral_
  - typingsSlinky.babelTypes.mod.NumericLiteral_
  - typingsSlinky.babelTypes.mod.NullLiteral_
  - typingsSlinky.babelTypes.mod.BooleanLiteral_
  - typingsSlinky.babelTypes.mod.RegExpLiteral_
  - typingsSlinky.babelTypes.mod.LogicalExpression_
  - typingsSlinky.babelTypes.mod.MemberExpression_
  - typingsSlinky.babelTypes.mod.NewExpression_
  - typingsSlinky.babelTypes.mod.ObjectExpression_
  - typingsSlinky.babelTypes.mod.SequenceExpression_
  - typingsSlinky.babelTypes.mod.ParenthesizedExpression_
  - typingsSlinky.babelTypes.mod.ThisExpression_
  - typingsSlinky.babelTypes.mod.UnaryExpression_
  - typingsSlinky.babelTypes.mod.UpdateExpression_
  - typingsSlinky.babelTypes.mod.ArrowFunctionExpression_
  - typingsSlinky.babelTypes.mod.ClassExpression_
  - typingsSlinky.babelTypes.mod.MetaProperty_
  - typingsSlinky.babelTypes.mod.Super_
  - typingsSlinky.babelTypes.mod.TaggedTemplateExpression_
  - typingsSlinky.babelTypes.mod.TemplateLiteral_
  - typingsSlinky.babelTypes.mod.YieldExpression_
  - typingsSlinky.babelTypes.mod.TypeCastExpression_
  - typingsSlinky.babelTypes.mod.JSXElement_
  - typingsSlinky.babelTypes.mod.JSXFragment_
  - typingsSlinky.babelTypes.mod.AwaitExpression_
  - typingsSlinky.babelTypes.mod.BindExpression_
  - typingsSlinky.babelTypes.mod.OptionalMemberExpression_
  - typingsSlinky.babelTypes.mod.PipelinePrimaryTopicReference_
  - typingsSlinky.babelTypes.mod.OptionalCallExpression_
  - typingsSlinky.babelTypes.mod.Import_
  - typingsSlinky.babelTypes.mod.DoExpression_
  - typingsSlinky.babelTypes.mod.BigIntLiteral_
  - typingsSlinky.babelTypes.mod.RecordExpression_
  - typingsSlinky.babelTypes.mod.TupleExpression_
  - typingsSlinky.babelTypes.mod.TSAsExpression_
  - typingsSlinky.babelTypes.mod.TSTypeAssertion_
  - typingsSlinky.babelTypes.mod.TSNonNullExpression_
*/
trait Expression extends Node

object Expression {
  @scala.inline
  implicit def apply(value: ArrayExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: ArrowFunctionExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: AssignmentExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: AwaitExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: BigIntLiteral_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: BinaryExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: BindExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: BooleanLiteral_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: CallExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: ClassExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: ConditionalExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: DoExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: FunctionExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: Identifier_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: Import_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: JSXElement_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: JSXFragment_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: LogicalExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: MemberExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: MetaProperty_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: NewExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: NullLiteral_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: NumericLiteral_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: ObjectExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: OptionalCallExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: OptionalMemberExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: ParenthesizedExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: PipelinePrimaryTopicReference_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: RecordExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: RegExpLiteral_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: SequenceExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: StringLiteral_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: Super_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: TSAsExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: TSNonNullExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: TSTypeAssertion_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: TaggedTemplateExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: TemplateLiteral_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: ThisExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: TupleExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: TypeCastExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: UnaryExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: UpdateExpression_): Expression = value.asInstanceOf[Expression]
  @scala.inline
  implicit def apply(value: YieldExpression_): Expression = value.asInstanceOf[Expression]
}

