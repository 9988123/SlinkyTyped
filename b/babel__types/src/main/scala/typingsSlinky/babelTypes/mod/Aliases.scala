package typingsSlinky.babelTypes.mod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait Aliases extends js.Object {
  var Binary: typingsSlinky.babelTypes.mod.Binary = js.native
  var Block: typingsSlinky.babelTypes.mod.Block = js.native
  var BlockParent: typingsSlinky.babelTypes.mod.BlockParent = js.native
  var Class: typingsSlinky.babelTypes.mod.Class = js.native
  var CompletionStatement: typingsSlinky.babelTypes.mod.CompletionStatement = js.native
  var Conditional: typingsSlinky.babelTypes.mod.Conditional = js.native
  var Declaration: typingsSlinky.babelTypes.mod.Declaration = js.native
  var EnumBody: typingsSlinky.babelTypes.mod.EnumBody = js.native
  var EnumMember: typingsSlinky.babelTypes.mod.EnumMember = js.native
  var ExportDeclaration: typingsSlinky.babelTypes.mod.ExportDeclaration = js.native
  var Expression: typingsSlinky.babelTypes.mod.Expression = js.native
  var ExpressionWrapper: typingsSlinky.babelTypes.mod.ExpressionWrapper = js.native
  var Flow: typingsSlinky.babelTypes.mod.Flow = js.native
  var FlowBaseAnnotation: typingsSlinky.babelTypes.mod.FlowBaseAnnotation = js.native
  var FlowDeclaration: typingsSlinky.babelTypes.mod.FlowDeclaration = js.native
  var FlowPredicate: typingsSlinky.babelTypes.mod.FlowPredicate = js.native
  var FlowType: typingsSlinky.babelTypes.mod.FlowType = js.native
  var For: typingsSlinky.babelTypes.mod.For = js.native
  var ForXStatement: typingsSlinky.babelTypes.mod.ForXStatement = js.native
  var Function: typingsSlinky.babelTypes.mod.Function = js.native
  var FunctionParent: typingsSlinky.babelTypes.mod.FunctionParent = js.native
  var Immutable: typingsSlinky.babelTypes.mod.Immutable = js.native
  var JSX: typingsSlinky.babelTypes.mod.JSX = js.native
  var LVal: typingsSlinky.babelTypes.mod.LVal = js.native
  var Literal: typingsSlinky.babelTypes.mod.Literal = js.native
  var Loop: typingsSlinky.babelTypes.mod.Loop = js.native
  var Method: typingsSlinky.babelTypes.mod.Method = js.native
  var ModuleDeclaration: typingsSlinky.babelTypes.mod.ModuleDeclaration = js.native
  var ModuleSpecifier: typingsSlinky.babelTypes.mod.ModuleSpecifier = js.native
  var ObjectMember: typingsSlinky.babelTypes.mod.ObjectMember = js.native
  var Pattern: typingsSlinky.babelTypes.mod.Pattern = js.native
  var PatternLike: typingsSlinky.babelTypes.mod.PatternLike = js.native
  var Private: typingsSlinky.babelTypes.mod.Private = js.native
  var Property: typingsSlinky.babelTypes.mod.Property = js.native
  var Pureish: typingsSlinky.babelTypes.mod.Pureish = js.native
  var Scopable: typingsSlinky.babelTypes.mod.Scopable = js.native
  var Statement: typingsSlinky.babelTypes.mod.Statement = js.native
  var TSEntityName: typingsSlinky.babelTypes.mod.TSEntityName = js.native
  var TSType: typingsSlinky.babelTypes.mod.TSType = js.native
  var TSTypeElement: typingsSlinky.babelTypes.mod.TSTypeElement = js.native
  var Terminatorless: typingsSlinky.babelTypes.mod.Terminatorless = js.native
  var UnaryLike: typingsSlinky.babelTypes.mod.UnaryLike = js.native
  var UserWhitespacable: typingsSlinky.babelTypes.mod.UserWhitespacable = js.native
  var While: typingsSlinky.babelTypes.mod.While = js.native
}

object Aliases {
  @scala.inline
  def apply(
    Binary: Binary,
    Block: Block,
    BlockParent: BlockParent,
    Class: Class,
    CompletionStatement: CompletionStatement,
    Conditional: Conditional,
    Declaration: Declaration,
    EnumBody: EnumBody,
    EnumMember: EnumMember,
    ExportDeclaration: ExportDeclaration,
    Expression: Expression,
    ExpressionWrapper: ExpressionWrapper,
    Flow: Flow,
    FlowBaseAnnotation: FlowBaseAnnotation,
    FlowDeclaration: FlowDeclaration,
    FlowPredicate: FlowPredicate,
    FlowType: FlowType,
    For: For,
    ForXStatement: ForXStatement,
    Function: Function,
    FunctionParent: FunctionParent,
    Immutable: Immutable,
    JSX: JSX,
    LVal: LVal,
    Literal: Literal,
    Loop: Loop,
    Method: Method,
    ModuleDeclaration: ModuleDeclaration,
    ModuleSpecifier: ModuleSpecifier,
    ObjectMember: ObjectMember,
    Pattern: Pattern,
    PatternLike: PatternLike,
    Private: Private,
    Property: Property,
    Pureish: Pureish,
    Scopable: Scopable,
    Statement: Statement,
    TSEntityName: TSEntityName,
    TSType: TSType,
    TSTypeElement: TSTypeElement,
    Terminatorless: Terminatorless,
    UnaryLike: UnaryLike,
    UserWhitespacable: UserWhitespacable,
    While: While
  ): Aliases = {
    val __obj = js.Dynamic.literal(Binary = Binary.asInstanceOf[js.Any], Block = Block.asInstanceOf[js.Any], BlockParent = BlockParent.asInstanceOf[js.Any], Class = Class.asInstanceOf[js.Any], CompletionStatement = CompletionStatement.asInstanceOf[js.Any], Conditional = Conditional.asInstanceOf[js.Any], Declaration = Declaration.asInstanceOf[js.Any], EnumBody = EnumBody.asInstanceOf[js.Any], EnumMember = EnumMember.asInstanceOf[js.Any], ExportDeclaration = ExportDeclaration.asInstanceOf[js.Any], Expression = Expression.asInstanceOf[js.Any], ExpressionWrapper = ExpressionWrapper.asInstanceOf[js.Any], Flow = Flow.asInstanceOf[js.Any], FlowBaseAnnotation = FlowBaseAnnotation.asInstanceOf[js.Any], FlowDeclaration = FlowDeclaration.asInstanceOf[js.Any], FlowPredicate = FlowPredicate.asInstanceOf[js.Any], FlowType = FlowType.asInstanceOf[js.Any], For = For.asInstanceOf[js.Any], ForXStatement = ForXStatement.asInstanceOf[js.Any], Function = Function.asInstanceOf[js.Any], FunctionParent = FunctionParent.asInstanceOf[js.Any], Immutable = Immutable.asInstanceOf[js.Any], JSX = JSX.asInstanceOf[js.Any], LVal = LVal.asInstanceOf[js.Any], Literal = Literal.asInstanceOf[js.Any], Loop = Loop.asInstanceOf[js.Any], Method = Method.asInstanceOf[js.Any], ModuleDeclaration = ModuleDeclaration.asInstanceOf[js.Any], ModuleSpecifier = ModuleSpecifier.asInstanceOf[js.Any], ObjectMember = ObjectMember.asInstanceOf[js.Any], Pattern = Pattern.asInstanceOf[js.Any], PatternLike = PatternLike.asInstanceOf[js.Any], Private = Private.asInstanceOf[js.Any], Property = Property.asInstanceOf[js.Any], Pureish = Pureish.asInstanceOf[js.Any], Scopable = Scopable.asInstanceOf[js.Any], Statement = Statement.asInstanceOf[js.Any], TSEntityName = TSEntityName.asInstanceOf[js.Any], TSType = TSType.asInstanceOf[js.Any], TSTypeElement = TSTypeElement.asInstanceOf[js.Any], Terminatorless = Terminatorless.asInstanceOf[js.Any], UnaryLike = UnaryLike.asInstanceOf[js.Any], UserWhitespacable = UserWhitespacable.asInstanceOf[js.Any], While = While.asInstanceOf[js.Any])
    __obj.asInstanceOf[Aliases]
  }
  @scala.inline
  implicit class AliasesOps[Self <: Aliases] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def withBinary(value: Binary): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Binary")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withBlock(value: Block): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Block")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withBlockParent(value: BlockParent): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("BlockParent")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withClass(value: Class): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Class")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withCompletionStatement(value: CompletionStatement): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("CompletionStatement")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withConditional(value: Conditional): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Conditional")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withDeclaration(value: Declaration): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Declaration")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withEnumBody(value: EnumBody): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("EnumBody")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withEnumMember(value: EnumMember): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("EnumMember")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withExportDeclaration(value: ExportDeclaration): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ExportDeclaration")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withExpression(value: Expression): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Expression")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withExpressionWrapper(value: ExpressionWrapper): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ExpressionWrapper")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withFlow(value: Flow): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Flow")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withFlowBaseAnnotation(value: FlowBaseAnnotation): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("FlowBaseAnnotation")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withFlowDeclaration(value: FlowDeclaration): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("FlowDeclaration")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withFlowPredicate(value: FlowPredicate): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("FlowPredicate")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withFlowType(value: FlowType): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("FlowType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withFor(value: For): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("For")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withForXStatement(value: ForXStatement): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ForXStatement")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withFunction(value: Function): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Function")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withFunctionParent(value: FunctionParent): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("FunctionParent")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withImmutable(value: Immutable): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Immutable")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withJSX(value: JSX): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("JSX")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLVal(value: LVal): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("LVal")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLiteral(value: Literal): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Literal")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withLoop(value: Loop): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Loop")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withMethod(value: Method): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Method")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withModuleDeclaration(value: ModuleDeclaration): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ModuleDeclaration")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withModuleSpecifier(value: ModuleSpecifier): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ModuleSpecifier")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withObjectMember(value: ObjectMember): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("ObjectMember")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withPattern(value: Pattern): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Pattern")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withPatternLike(value: PatternLike): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("PatternLike")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withPrivate(value: Private): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Private")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withProperty(value: Property): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Property")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withPureish(value: Pureish): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Pureish")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withScopable(value: Scopable): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Scopable")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withStatement(value: Statement): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Statement")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withTSEntityName(value: TSEntityName): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("TSEntityName")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withTSType(value: TSType): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("TSType")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withTSTypeElement(value: TSTypeElement): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("TSTypeElement")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withTerminatorless(value: Terminatorless): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("Terminatorless")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withUnaryLike(value: UnaryLike): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("UnaryLike")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withUserWhitespacable(value: UserWhitespacable): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("UserWhitespacable")(value.asInstanceOf[js.Any])
        ret
    }
    @scala.inline
    def withWhile(value: While): Self = {
        val ret = this.duplicate
        ret.asInstanceOf[js.Dynamic].updateDynamic("While")(value.asInstanceOf[js.Any])
        ret
    }
  }
  
}

